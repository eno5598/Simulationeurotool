<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>EuroJackpot • Realistischere Ziehung (Matter.js + Gate-Klappe)</title>
<link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
<script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/matter-js@0.19.0/build/matter.min.js"></script>
<style>
:root{ --ink:#eaf7ff; --bg:#060712; --cy:#00fff0; --mag:#ff00ea; --ok:#39ff88; --amber:#f59e0b; --panel:rgba(18,22,40,.75); }
body{background:radial-gradient(900px 700px at -10% -10%, rgba(0,255,240,.08), transparent 60%), radial-gradient(900px 700px at 110% -10%, rgba(255,0,234,.08), transparent 60%), var(--bg); color:var(--ink); font-family:Inter, ui-sans-serif, system-ui;}
.h1{background:linear-gradient(90deg,var(--cy),var(--mag)); -webkit-background-clip:text; color:transparent; font-weight:900}
.card{background:var(--panel); backdrop-filter: blur(10px); border:1px solid rgba(255,255,255,.1); border-radius:14px; padding:14px; box-shadow: 0 10px 30px rgba(0,0,0,.4);}
.btn{display:inline-flex;align-items:center;justify-content:center;gap:.5rem;height:44px;padding:0 12px;border-radius:12px;border:1px solid rgba(255,255,255,.08);font-weight:700}
.btn--green{background:#15803d;color:#fff;} .btn--amber{background:#b45309;color:#fff;} .btn--gray{background:#374151;color:#fff;}
.kpi{background:rgba(255,255,255,.04); border:1px solid rgba(140,170,255,.18); border-radius:12px; padding:6px 10px; font-size:.9rem}
.grid2{display:grid; grid-template-columns:1fr; gap:14px}
@media (min-width: 900px){ .grid2{grid-template-columns:1fr 1fr} }
.simwrap{position:relative; border-radius:12px; overflow:hidden; border:1px solid rgba(255,255,255,.06); background:#050a12}
.simwrap canvas{width:100%; height:420px; max-height:60vh; background:radial-gradient(60% 80% at 50% 40%, #0a1421, #060c15)}
.label{position:absolute; top:10px; left:12px; font-size:14px; opacity:.85}
.bubble{display:inline-block; padding:2px 8px; border-radius:10px; background:rgba(0,0,0,.35); border:1px solid rgba(255,255,255,.12)}
.outslot{position:absolute; right:10px; top:10px; width:90px; height:90px; border-radius:12px; border:1px solid rgba(0,255,200,.25); background:rgba(0,255,170,.08); display:flex;align-items:center;justify-content:center; font-size:12px; color:#8bffc9}
.badge{background:rgba(255,255,255,.06); border:1px solid rgba(140,170,255,.22); border-radius:999px; padding:.15rem .6rem; font-size:.74rem;}
</style>
</head>
<body class="p-4">
  <h1 class="h1 text-3xl md:text-4xl mb-3">EuroJackpot • Realistischere Ziehung</h1>
  <div class="grid grid-cols-1 lg:grid-cols-3 gap-3">
    <section class="card lg:col-span-2">
      <h2 class="font-bold text-xl mb-2">🌀 Simulation (2 Trommeln, Gate‑Klappe)</h2>
      <p class="text-sm opacity-80 mb-2">Physik-Engine (Matter.js) mit Kollisionen, rotierenden Paddeln, **Klappe am Gate** und kontrolliertem Auswurf. Haupt 1–50 (5 Kugeln), Euro 1–12 (2 Kugeln). Start schießt nichts mehr heraus – Gate bleibt zu bis zur Ziehung.</p>
      <div class="grid2">
        <div class="simwrap">
          <div class="label"><span class="bubble">Haupttrommel (1–50)</span></div>
          <div class="outslot">Auswurf</div>
          <canvas id="canvasA" width="640" height="420"></canvas>
        </div>
        <div class="simwrap">
          <div class="label"><span class="bubble">Eurotrommel (1–12)</span></div>
          <div class="outslot">Auswurf</div>
          <canvas id="canvasB" width="640" height="420"></canvas>
        </div>
      </div>
      <div class="flex flex-wrap gap-2 mt-2">
        <button id="btnStartDraw" class="btn btn--green">Ziehung starten (5+2)</button>
        <button id="btnStop" class="btn btn--gray">Simulation stoppen</button>
        <button id="btnReset" class="btn btn--amber">Simulation reset</button>
      </div>
      <div id="result" class="mt-3 text-lg"><span class="badge">Noch kein Ergebnis</span></div>
    </section>
    <section class="card">
      <h2 class="font-bold text-xl mb-2">📂 Archiv (Auto + Fallback)</h2>
      <p id="statusText" class="text-sm opacity-80 mb-2">Noch kein Archiv geladen.</p>
      <div class="mb-2">
        <input id="archiveUrl" class="bg-gray-900 p-2 rounded w-full" value="https://www.lotto-bayern.de/static/gamebroker_2/de/download_files/archiv_eurojackpot.zip">
      </div>
      <div class="flex flex-wrap gap-2 mb-2">
        <button id="loadLatestBtn" class="btn btn--green">📥 Neueste laden</button>
        <button id="forceDlBtn" class="btn btn--amber">⬇️ ZIP speichern</button>
        <a id="directDl" class="btn btn--gray" target="_blank" rel="noopener">🔗 Direktlink</a>
      </div>
      <div class="grid grid-cols-2 gap-2 text-center my-2">
        <div class="kpi">Ziehungen: <b id="kpiCount">–</b></div>
        <div class="kpi">Bis: <b id="kpiTo">–</b></div>
      </div>
      <div class="flex flex-wrap gap-2 mb-2">
        <label class="btn btn--gray cursor-pointer">📄 Datei wählen
          <input id="zipInput" type="file" class="hidden" accept=".zip,.txt,.csv">
        </label>
        <button id="pasteBtn" class="btn btn--gray">📋 CSV/TXT einfügen</button>
      </div>
      <div id="fileName" class="text-xs opacity-70">Keine Datei ausgewählt</div>
    </section>
  </div>

<script>
/* ---------- Archiv: robust auto-downloader (wie zuvor) ---------- */
const LS_ARCH='ej_archive_v5', LS_LASTCHECK='ej_last_check_v5';
const $ = s=>document.querySelector(s);
function parseText(txt){
  try{
    const t=txt.replace(/\r\n?/g,'\n'), head=t.slice(0,2000);
    const delim = (head.match(/\t/g)||[]).length>(head.match(/;/g)||[]).length ? '\\t' : (head.match(/;/g)||[]).length? ';' : ',';
    const lines=t.split('\\n').map(l=>l.trim()).filter(Boolean);
    const h=lines[0].split(delim).map(x=>x.trim());
    const idx={
      Tag:h.findIndex(x=>/tag/i.test(x)), Monat:h.findIndex(x=>/monat|month/i.test(x)), Jahr:h.findIndex(x=>/jahr|year/i.test(x)),
      A:[1,2,3,4,5].map(k=>h.findIndex(x=>new RegExp('ZahlA'+k,'i').test(x))), B:[1,2].map(k=>h.findIndex(x=>new RegExp('ZahlB'+k,'i').test(x)))
    };
    if(idx.Tag<0||idx.Monat<0||idx.Jahr<0||idx.A.some(i=>i<0)||idx.B.some(i=>i<0)) throw new Error('Kopfzeile nicht erkannt. Erwartet: Tag, Monat, Jahr, ZahlA1..5, ZahlB1..2');
    const out=[];
    for(let i=1;i<lines.length;i++){
      const c=lines[i].split(h.includes(';')?';':(h.includes('\\t')?'\\t':',')).map(s=>s.trim());
      if(c.length <= Math.max(...idx.A, ...idx.B)) continue;
      const A = idx.A.map(ii=>+c[ii]).filter(Number.isFinite);
      const B = idx.B.map(ii=>+c[ii]).filter(Number.isFinite);
      const day=+c[idx.Tag], mon=+c[idx.Monat], year=+c[idx.Jahr];
      if(A.length===5 && B.length===2){
        const date=new Date(Date.UTC(year,mon-1,day)).toISOString().slice(0,10);
        out.push({date, main:A.slice().sort((a,b)=>a-b), euro:B.slice().sort((a,b)=>a-b)});
      }
    }
    out.sort((a,b)=>a.date.localeCompare(b.date));
    $('#kpiCount').textContent = out.length; $('#kpiTo').textContent = out.at(-1)?.date || '–';
    $('#statusText').textContent = 'Archiv geladen ✔';
    return out;
  }catch(e){ $('#statusText').textContent = 'Fehler: '+e.message; return []; }
}
async function fetchWithProxies(url){
  const trials=[url,'https://cors.isomorphic-git.org/'+url,'https://api.allorigins.win/raw?url='+encodeURIComponent(url),'https://thingproxy.freeboard.io/fetch/'+url,'https://corsproxy.io/?'+encodeURIComponent(url)];
  for(const u of trials){
    try{
      const res=await fetch(u,{cache:'no-store'});
      if(!res.ok) throw new Error('HTTP '+res.status);
      const ct=res.headers.get('content-type')||'';
      if(ct.includes('zip')||u.endsWith('.zip')){
        const blob=await res.blob(); const zip=await JSZip.loadAsync(blob); let combo='';
        for(const f of Object.values(zip.files)){ if(/\\.(txt|csv)$/i.test(f.name)){ combo += "\\n" + await f.async('string'); } }
        return combo;
      }else{ return await res.text(); }
    }catch(e){}
  }
  throw new Error('Download fehlgeschlagen (alle Proxies).');
}
async function loadLatest(){
  const url=$('#archiveUrl').value.trim();
  $('#statusText').textContent='Online-Archiv wird geprüft…';
  try{
    const raw=await fetchWithProxies(url);
    const arr=parseText(raw);
    localStorage.setItem(LS_ARCH, raw);
    localStorage.setItem(LS_LASTCHECK, new Date().toISOString().replace('T',' ').slice(0,16));
  }catch(e){
    const saved=localStorage.getItem(LS_ARCH);
    if(saved){ parseText(saved); $('#statusText').textContent='Online-Check fehlgeschlagen, lokale Kopie geladen.'; }
    else{ $('#statusText').textContent='Kein Archiv verfügbar.'; }
  }
}
$('#loadLatestBtn').addEventListener('click', loadLatest);
$('#forceDlBtn').addEventListener('click', async ()=>{
  const url=$('#archiveUrl').value.trim();
  try{ const res=await fetch(url); const blob=await res.blob(); const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='archiv_eurojackpot.zip'; a.click(); }catch(e){ alert('Direkt-Download nicht möglich.'); }
});
$('#directDl').href=$('#archiveUrl').value.trim();
$('#zipInput').addEventListener('change', async (e)=>{
  const f=e.target.files[0]; if(!f) return; $('#fileName').textContent=f.name;
  if(f.name.endsWith('.zip')){ const zip=await JSZip.loadAsync(f); let combo=''; for(const file of Object.values(zip.files)){ if(/\\.(txt|csv)$/i.test(file.name)){ combo+="\\n"+await file.async('string'); } } parseText(combo); localStorage.setItem(LS_ARCH, combo); }
  else { const txt=await f.text(); parseText(txt); localStorage.setItem(LS_ARCH, txt); }
});
$('#pasteBtn').addEventListener('click', ()=>{
  const sample="Tag\\tMonat\\tJahr\\tZahlA1\\tZahlA2\\tZahlA3\\tZahlA4\\tZahlA5\\tZahlB1\\tZahlB2\\n23\\t3\\t2012\\t5\\t46\\t37\\t21\\t8\\t8\\t6";
  const t=prompt('Füge CSV/TXT-Inhalt (mit Kopfzeile) ein:', sample); if(!t) return; parseText(t); localStorage.setItem(LS_ARCH, t);
});
(function(){ const saved=localStorage.getItem(LS_ARCH); if(saved){ parseText(saved);} else { loadLatest(); } })();


/* ---------- Simulation mit Matter.js: 2 Trommeln + Gate‑Klappe ---------- */
const {Engine, Render, Runner, Bodies, Body, Composite, Constraint, Events, World, Vector} = Matter;

function createDrum(canvas, opts){
  const engine = Engine.create({gravity:{x:0,y:0}});
  const world = engine.world;
  const W = canvas.clientWidth, H = canvas.clientHeight;
  canvas.width=W; canvas.height=H;

  const render = Render.create({ canvas, engine, options:{ width:W, height:H, wireframes:false, background:"transparent", pixelRatio:Math.min(2, window.devicePixelRatio||1) } });

  const cx=W*0.48, cy=H*0.58;
  const radius = Math.min(W,H)*0.38;
  const wallThickness = 22;
  const segs = 28;
  const walls=[];
  const openStart = -Math.PI*0.18, openEnd = Math.PI*0.05; // Gate-Sektor (geschlossen durch Klappe)
  for(let i=0;i<segs;i++){
    const angle=(i/segs)*Math.PI*2, aNorm=angle - Math.PI/2;
    // wir bauen überall Wände, auch im Gate – die Klappe überdeckt / öffnet das Fenster
    const x=cx + Math.cos(angle)*radius, y=cy + Math.sin(angle)*radius;
    const rect = Bodies.rectangle(x,y, wallThickness, (Math.PI*2*radius)/segs + 2, {isStatic:true, angle:angle+Math.PI/2, render:{fillStyle:"#0b1e2a"}});
    walls.push(rect);
  }
  // "Fenster" wird als dünne Wand markiert, die von der Klappe überlappt wird – für Exit wird Klappe wegschwenken und die dünne Wand transparent sein
  World.add(world, walls);

  // Klappe (Gate flap): um Scharnier drehen, deckt Öffnung ab
  const gateAngle = (openStart+openEnd)/2 + Math.PI/2;
  const flapW = wallThickness*1.2, flapH = radius*0.5;
  const flapX = cx + Math.cos(gateAngle)*(radius - flapH/2);
  const flapY = cy + Math.sin(gateAngle)*(radius - flapH/2);
  const flap = Bodies.rectangle(flapX, flapY, flapW, flapH, { chamfer:{radius:4}, render:{fillStyle:"#164a49"}, frictionAir:0.02 });
  const hinge = Constraint.create({ pointA:{x: cx + Math.cos(gateAngle)*(radius - flapH), y: cy + Math.sin(gateAngle)*(radius - flapH)}, bodyB: flap, pointB:{x:0, y:-flapH/2+2}, length:0, stiffness:1 });
  World.add(world, [flap, hinge]);

  // Paddel (rühren)
  const bladeLen = radius*0.82;
  const spinnerA = Bodies.rectangle(cx, cy, bladeLen, 12, {density:0.004, frictionAir:0.04, render:{fillStyle:"#17c3b2"}});
  const spinnerB = Bodies.rectangle(cx, cy, 12, bladeLen, {density:0.004, frictionAir:0.04, render:{fillStyle:"#17c3b2"}});
  const pivot = Constraint.create({pointA:{x:cx,y:cy}, bodyB:spinnerA, length:0, stiffness:1});
  const pivot2= Constraint.create({pointA:{x:cx,y:cy}, bodyB:spinnerB, length:0, stiffness:1});
  World.add(world,[spinnerA, spinnerB, pivot, pivot2]);

  // Unsichtbare Außenbox, damit nichts entkommt
  const bounds= [
    Bodies.rectangle(W/2,-50,W+200,100,{isStatic:true, render:{visible:false}}),
    Bodies.rectangle(W/2,H+50,W+200,100,{isStatic:true, render:{visible:false}}),
    Bodies.rectangle(-50,H/2,100,H+200,{isStatic:true, render:{visible:false}}),
    Bodies.rectangle(W+50,H/2,100,H+200,{isStatic:true, render:{visible:false}}),
  ];
  World.add(world, bounds);

  // Kugeln non-overlapping spawnen (Hex-Gitter)
  const balls=[]; const n=opts.count; const labels=opts.labels;
  const rBall=Math.max(10, radius*0.08);
  const cols=Math.ceil(Math.sqrt(n)), rows=Math.ceil(n/cols);
  let idx=0;
  for(let r=0;r<rows;r++){
    for(let c=0;c<cols;c++){
      if(idx>=n) break;
      const jitter=()=> (Math.random()-0.5)*rBall*0.4;
      const ang=(r*cols+c)/n*Math.PI*2;
      const rr = radius*0.55;
      const x=cx + Math.cos(ang)*rr + jitter();
      const y=cy + Math.sin(ang)*rr + jitter();
      const b=Bodies.circle(x,y,rBall,{ restitution:0.82, friction:0.02, frictionAir:0.02, density:0.0015, render:{fillStyle:"#0ba5a4", strokeStyle:"rgba(255,255,255,0.06)", lineWidth:1} });
      b.labelNum = labels[idx++];
      balls.push(b);
    }
  }
  World.add(world, balls);

  const runner = Runner.create();

  // Gate-Bereich für Erkennung (rechte obere Zone)
  const gateBox = (()=>{
    const gx = cx + Math.cos(gateAngle)*(radius-20);
    const gy = cy + Math.sin(gateAngle)*(radius-20);
    return {x1:gx-22,y1:gy-22,x2:gx+40,y2:gy+40};
  })();

  let mixing=true;
  function setMixing(m){ mixing=m; }
  Events.on(runner, "beforeUpdate", ()=>{
    Body.setAngularVelocity(spinnerA, mixing?1.8:0.4);
    Body.setAngularVelocity(spinnerB, mixing?-1.6:-0.3);
    // Klappe standardmäßig geschlossen: ziehe sie per kleiner Gegenkraft zu
    Body.setAngle(flap, gateAngle); Body.setAngularVelocity(flap, 0);
  });

  function start(){ Render.run(render); Runner.run(runner, engine); }
  function stop(){ Render.stop(render); Runner.stop(runner); }
  function reset(){ stop(); World.clear(world,false); Engine.clear(engine); }

  // Zahlen overlayn
  Events.on(render,"afterRender",()=>{
    const ctx=render.context; ctx.save(); ctx.font="bold 14px system-ui"; ctx.textAlign="center"; ctx.textBaseline="middle";
    for(const b of balls){ ctx.fillStyle = (b.render.fillStyle==="#f9d67a")?"#1a1206":"#eafffb"; ctx.fillText(String(b.labelNum).padStart(2,"0"), b.position.x, b.position.y); }
    // Gate-Markierung
    ctx.strokeStyle="rgba(140,255,220,.25)"; ctx.strokeRect(gateBox.x1, gateBox.y1, gateBox.x2-gateBox.x1, gateBox.y2-gateBox.y1);
    ctx.restore();
  });

  // Klappe öffnen → kurze Zeit offen halten → wieder schließen
  async function openFlap(msOpen=600){
    // swing open by rotating around hinge point (simulate with small offset impulses)
    for(let t=0;t<10;t++){ Body.rotate(flap, 0.09); await sleep(12); }
    await sleep(msOpen);
    for(let t=0;t<10;t++){ Body.rotate(flap, -0.09); await sleep(12); }
    Body.setAngle(flap, gateAngle);
  }

  function checkGate(){
    for(const b of balls){
      if(b.picked) continue;
      if(b.position.x>gateBox.x1 && b.position.x<gateBox.x2 && b.position.y>gateBox.y1 && b.position.y<gateBox.y2){
        // nach rechts oben "raus" schubsen
        Body.setVelocity(b,{x:10,y:-2}); Body.setAngularVelocity(b,3);
        b.picked=true; b.render.fillStyle="#f9d67a"; return b;
      }
    }
    return null;
  }

  async function drawOne(){ // öffnet Klappe, wartet, nimmt 1 Kugel
    await openFlap(500);
    const t0=performance.now();
    while(performance.now()-t0 < 1500){
      const got = checkGate();
      if(got) return got;
      await sleep(16);
    }
    return null;
  }

  return { start, stop, reset, drawOne, setMixing, getNumbers:()=>balls.filter(b=>b.picked).map(b=>b.labelNum).sort((a,b)=>a-b) };
}

function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }

// Trommeln bauen
const drumA = createDrum(document.getElementById('canvasA'), {count:50, labels:[...Array(50)].map((_,i)=>i+1)});
const drumB = createDrum(document.getElementById('canvasB'), {count:12, labels:[...Array(12)].map((_,i)=>i+1)});
drumA.start(); drumB.start();

// Controls
document.getElementById('btnStop').addEventListener('click', ()=>{ drumA.stop(); drumB.stop(); });
document.getElementById('btnReset').addEventListener('click', ()=>{ location.reload(); });

// Ziehung 5 + 2
document.getElementById('btnStartDraw').addEventListener('click', async ()=>{
  const btn = document.getElementById('btnStartDraw'); if(btn.disabled) return; btn.disabled=true;
  drumA.setMixing(true); drumB.setMixing(true);
  const result={main:[], euro:[], created_at:new Date().toISOString()};
  await sleep(800); // warm-up
  for(let i=0;i<5;i++){ const b=await drumA.drawOne(); if(b) result.main.push(b.labelNum); await sleep(300); }
  await sleep(600);
  for(let i=0;i<2;i++){ const b=await drumB.drawOne(); if(b) result.euro.push(b.labelNum); await sleep(300); }
  result.main.sort((a,b)=>a-b); result.euro.sort((a,b)=>a-b);
  document.getElementById('result').innerHTML=`<b>Ergebnis:</b> Haupt: ${result.main.map(n=>String(n).padStart(2,'0')).join(' ')} · Euro: ${result.euro.map(n=>String(n).padStart(2,'0')).join(' ')}<div class="text-xs opacity-80">${result.created_at}</div>`;
  btn.disabled=false;
});
</script>
</body>
</html>
