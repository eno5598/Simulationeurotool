<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>EuroJackpot – Simulation, Tippgenerator & Auto-Update</title>
<style>
:root{--bg:#0b0f14; --card:#0f1720; --muted:#8aa1b1; --text:#e9f1f7; --accent:#2ea44f; --chip:#1a232b; --accent-2:#7dd3fc; --danger:#cc444b}
*{box-sizing:border-box} body{margin:0;font-family:system-ui,Segoe UI,Roboto,Arial;background:var(--bg);color:var(--text);-webkit-font-smoothing:antialiased}
.container{max-width:1100px;margin:0 auto;padding:18px}
.header{display:flex;align-items:center;justify-content:space-between;gap:12px}
h1{font-size:20px;margin:0}
.card{background:var(--card);border:1px solid #1f2b36;border-radius:12px;padding:12px;margin:12px 0}
.grid{display:grid;grid-template-columns:1fr 420px;gap:12px}
@media (max-width:900px){ .grid{grid-template-columns:1fr} .rightcol{order:2} }
.controls{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
.btn{background:#16313b;color:#dff3ff;border:1px solid #234; padding:8px 10px;border-radius:8px;cursor:pointer}
.btn.primary{background:var(--accent);color:#04210a;font-weight:700}
.small{color:var(--muted);font-size:13px}
.flex{display:flex;gap:8px;align-items:center}
.canvas-wrap{background:#071018;border-radius:8px;padding:8px;display:flex;flex-direction:column;align-items:center}
canvas{background:linear-gradient(180deg,#08121a,#061116);border-radius:6px;border:1px solid rgba(255,255,255,0.03);width:100%;height:360px;max-height:60vh}
.controls input[type="number"]{width:80px;padding:6px;border-radius:6px;border:1px solid #233; background:#081218;color:var(--text)}
.kv{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
.ball-ui{display:flex;gap:6px;flex-wrap:wrap}
.badge{padding:6px 10px;border-radius:999px;background:#0f2b2a;border:1px solid #123;color:#9feee6;font-weight:600}
.tips{display:flex;flex-direction:column;gap:8px;margin-top:8px}
.tip{background:#08131a;border-radius:8px;padding:8px;border:1px solid #163a3b}
.note{font-size:13px;color:var(--muted)}
.switch{display:inline-flex;align-items:center;gap:8px}
.footer{font-size:12px;color:var(--muted);margin-top:12px}
@media (max-width:500px){ canvas{height:260px} }
</style>
</head>
<body>
<div class="container">
  <div class="header">
    <h1>EuroJackpot – Simulation & Tipp-Generator</h1>
    <div class="small">Auto-update on load possible · Mobile-ready</div>
  </div>

  <div class="card grid">
    <!-- Left: analysis + simulation -->
    <div>
      <div class="card">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <strong>Archiv & Einstellungen</strong>
          <div class="small">Version Demo</div>
        </div>
        <p class="small">Die Seite lädt beim Start optional das angegebene Archiv (ZIP) – falls CORS blockiert, lade bitte manuell hoch.</p>
        <div class="flex" style="margin-top:8px">
          <input id="zipUrl" type="url" value="https://www.lotto-bayern.de/static/gamebroker_2/de/download_files/archiv_eurojackpot.zip" style="flex:1;padding:8px;border-radius:8px;border:1px solid #233;background:#071218;color:var(--text)">
          <button id="btnFetch" class="btn">Laden</button>
        </div>
        <div class="kv">
          <label class="switch small"><input type="checkbox" id="autoUpdate"> <span>Auto-Update beim Laden</span></label>
          <button id="btnLoadLocal" class="btn">Manuell: Datei hochladen</button>
          <input id="fileInput" type="file" accept=".zip,.csv,.txt" style="display:none">
        </div>
        <div id="dlStatus" class="small note" style="margin-top:8px"></div>
      </div>

      <div class="card" style="margin-top:12px">
        <strong>Simulation (visuell)</strong>
        <div class="canvas-wrap" style="margin-top:8px">
          <canvas id="simCanvas" width="800" height="420"></canvas>
          <div class="kv" style="width:100%;justify-content:space-between">
            <div class="small">Kugeln simuliert: <span id="simCount">50</span></div>
            <div class="flex">
              <button id="btnStartSim" class="btn">Start</button>
              <button id="btnStopSim" class="btn">Stop</button>
              <button id="btnResetSim" class="btn">Reset</button>
            </div>
          </div>
        </div>
        <p class="small note" style="margin-top:8px">Die Simulation ist eine chaotische physikähnliche Modellierung (2D), keine offizielle Nachbildung. Zufall basiert auf numerischer Chaosdynamik + PRNG.</p>
      </div>
    </div>

    <!-- Right: settings + generator -->
    <div class="rightcol">
      <div class="card">
        <strong>Tippgenerator</strong>
        <div style="margin-top:8px" class="small">Wähle wie viele Tipps pro Klick generiert werden sollen (z. B. 1–20).</div>
        <div class="kv" style="margin-top:8px;align-items:center">
          <label class="small">Anzahl Tipps:</label>
          <input id="numTips" type="number" min="1" max="100" value="5">
          <label class="small">Auto-Simulation bei Ziehung:</label>
          <input id="autoSimOnDraw" type="checkbox">
        </div>
        <div style="margin-top:8px;display:flex;gap:8px;flex-wrap:wrap">
          <button id="btnGenerate" class="btn primary">Generiere Tipps</button>
          <button id="btnGenerateHot" class="btn">Hot-gewichtet</button>
          <button id="btnGenerateCold" class="btn">Cold-gewichtet</button>
          <button id="btnExportAll" class="btn">Export (ZIP)</button>
        </div>
        <div class="tips" id="tipsList" style="margin-top:12px"></div>
        <div style="margin-top:8px" class="small">Jeder Tipp enthält 5 Hauptzahlen (1–50) und 2 Eurozahlen (1–12). Du kannst auf einen Tipp klicken, um die Simulation für diese Ziehung automatisch ablaufen zu lassen (falls aktiviert).</div>
      </div>

      <div class="card" style="margin-top:12px">
        <strong>Live-Analyse</strong>
        <div id="analysis" style="margin-top:8px" class="small">Keine Daten geladen.</div>
      </div>
    </div>
  </div>

  <div class="footer small">Hinweis: Physikdetails wie Kugelgewicht oder offizielle Maschinen-Parameter sind nicht öffentlich. Diese Simulation dient nur zu Visualisierung und Lernzwecken. Daten bleiben lokal.</div>
</div>

<script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
<script>
/* Main app: loads archive if requested, provides simulation, and generates multiple tips */
(async function(){
  // state
  let draws = []; // historical draws from archive
  let freqA = Array(51).fill(0), freqB = Array(13).fill(0);
  const sim = createSimulator(document.getElementById('simCanvas'));

  // DOM refs
  const dlStatus = document.getElementById('dlStatus');
  const btnFetch = document.getElementById('btnFetch');
  const zipUrlInput = document.getElementById('zipUrl');
  const autoUpdateCheckbox = document.getElementById('autoUpdate');
  const fileInput = document.getElementById('fileInput');
  const btnLoadLocal = document.getElementById('btnLoadLocal');
  const simCountLabel = document.getElementById('simCount');
  const btnStartSim = document.getElementById('btnStartSim');
  const btnStopSim = document.getElementById('btnStopSim');
  const btnResetSim = document.getElementById('btnResetSim');
  const btnGenerate = document.getElementById('btnGenerate');
  const btnGenerateHot = document.getElementById('btnGenerateHot');
  const btnGenerateCold = document.getElementById('btnGenerateCold');
  const tipsList = document.getElementById('tipsList');
  const numTipsInput = document.getElementById('numTips');
  const autoSimOnDraw = document.getElementById('autoSimOnDraw');
  const btnExportAll = document.getElementById('btnExportAll');
  const btnUseAuto = autoUpdateCheckbox;

  // init
  simCountLabel.textContent = 50;
  attachEvents();

  // Auto-load on start if enabled last time
  try{ const auto = localStorage.getItem('ej_auto_update'); if (auto==='1'){ autoUpdateCheckbox.checked=true; await tryAutoLoad(); } }catch(e){}

  async function tryAutoLoad(){
    const url = zipUrlInput.value.trim();
    if (!url) return;
    dlStatus.textContent = 'Versuche automatisches Laden…';
    try{
      const res = await fetch(url);
      if (!res.ok) throw new Error('HTTP '+res.status);
      const buf = await res.arrayBuffer();
      const zip = await JSZip.loadAsync(buf);
      const file = Object.keys(zip.files).find(p=>/\.(csv|txt)$/i.test(p)) || Object.keys(zip.files)[0];
      const text = await zip.file(file).async('string');
      parseArchiveTextAndStore(text);
      dlStatus.textContent = 'Archiv automatisch geladen.';
    }catch(err){
      dlStatus.textContent = 'Auto-Update fehlgeschlagen (CORS oder Netzwerk): lade manuell.';
    }
  }

  function attachEvents(){
    btnFetch.addEventListener('click', async ()=>{
      dlStatus.textContent = 'Lade…';
      try{
        const res = await fetch(zipUrlInput.value.trim());
        if (!res.ok) throw new Error('HTTP '+res.status);
        const buf = await res.arrayBuffer();
        const zip = await JSZip.loadAsync(buf);
        const file = Object.keys(zip.files).find(p=>/\.(csv|txt)$/i.test(p)) || Object.keys(zip.files)[0];
        const text = await zip.file(file).async('string');
        parseArchiveTextAndStore(text);
        dlStatus.textContent = 'Archiv geladen.';
      }catch(err){
        dlStatus.textContent = 'Fehler beim Laden: '+err.message+' – bitte manuell hochladen.';
      }
    });

    btnLoadLocal.addEventListener('click', ()=> fileInput.click());
    fileInput.addEventListener('change', async (e)=>{
      const f = e.target.files[0]; if(!f) return;
      dlStatus.textContent = 'Lese Datei…';
      try{
        if (f.name.endsWith('.zip')){
          const zip = await JSZip.loadAsync(await f.arrayBuffer());
          const file = Object.keys(zip.files).find(p=>/\.(csv|txt)$/i.test(p)) || Object.keys(zip.files)[0];
          const text = await zip.file(file).async('string');
          parseArchiveTextAndStore(text);
        } else {
          const text = await f.text();
          parseArchiveTextAndStore(text);
        }
        dlStatus.textContent = 'Datei geladen.';
      }catch(err){
        dlStatus.textContent = 'Fehler: '+err.message;
      }
    });

    btnStartSim.addEventListener('click', ()=> sim.start());
    btnStopSim.addEventListener('click', ()=> sim.stop());
    btnResetSim.addEventListener('click', ()=> sim.reset());

    btnGenerate.addEventListener('click', ()=> generateTips('fair'));
    btnGenerateHot.addEventListener('click', ()=> generateTips('hot'));
    btnGenerateCold.addEventListener('click', ()=> generateTips('cold'));

    btnExportAll.addEventListener('click', exportAllZip);

    autoUpdateCheckbox.addEventListener('change', ()=>{
      localStorage.setItem('ej_auto_update', autoUpdateCheckbox.checked ? '1' : '0');
    });
  }

  function parseArchiveTextAndStore(text){
    try{
      // simple parser: accept tab or semicolon, detect header with Tag/Monat/Jahr/ZahlA1..5/ZahlB1..2
      const delim = (text.slice(0,2000).match(/\t/g)||[]).length > (text.slice(0,2000).match(/;/g)||[]).length ? '\t' : ';';
      const lines = text.split(/\r?\n/).map(l=>l.trim()).filter(Boolean);
      const header = lines[0].split(delim).map(h=>h.trim());
      const idx = {
        Tag: header.findIndex(h=>/tag/i.test(h)),
        Monat: header.findIndex(h=>/monat|month/i.test(h)),
        Jahr: header.findIndex(h=>/jahr|year/i.test(h)),
        A: [1,2,3,4,5].map(k=> header.findIndex(h=> new RegExp(`ZahlA${k}`, 'i').test(h))),
        B: [1,2].map(k=> header.findIndex(h=> new RegExp(`ZahlB${k}`, 'i').test(h)))
      };
      if (idx.Tag<0||idx.Monat<0||idx.Jahr<0||idx.A.some(i=>i<0)||idx.B.some(i=>i<0)){
        throw new Error('Unbekanntes Format – Kopfzeile nicht erkannt');
      }
      const out = [];
      for (let i=1;i<lines.length;i++){
        const cols = lines[i].split(delim).map(s=>s.trim());
        if (cols.length <= Math.max(...idx.A, ...idx.B)) continue;
        const day = parseInt(cols[idx.Tag],10);
        const month = parseInt(cols[idx.Monat],10);
        const year = parseInt(cols[idx.Jahr],10);
        const A = idx.A.map(ii=>parseInt(cols[ii],10)).filter(Number.isFinite);
        const B = idx.B.map(ii=>parseInt(cols[ii],10)).filter(Number.isFinite);
        if (A.length===5 && B.length===2){
          const date = `${year}-${String(month).padStart(2,'0')}-${String(day).padStart(2,'0')}`;
          out.push({date, main: A.slice().sort((a,b)=>a-b), euro: B.slice().sort((a,b)=>a-b)});
        }
      }
      out.sort((a,b)=> b.date.localeCompare(a.date)); // newest first
      draws = out;
      computeFreqs();
      localStorage.setItem('ej_draws', JSON.stringify(draws));
      updateAnalysisUI();
    }catch(err){
      dlStatus.textContent = 'Parser-Fehler: '+err.message;
    }
  }

  function computeFreqs(){
    freqA = Array(51).fill(0); freqB = Array(13).fill(0);
    draws.forEach(d=>{ d.main.forEach(n=> freqA[n]++); d.euro.forEach(n=> freqB[n]++); });
  }

  function updateAnalysisUI(){
    const analysis = document.getElementById('analysis');
    if (draws.length===0){ analysis.textContent = 'Keine Daten geladen.'; return; }
    const total = draws.length;
    const topA = [...Array(50)].map((_,i)=>({n:i+1,f:freqA[i+1]})).sort((a,b)=>b.f-a.f).slice(0,5);
    analysis.innerHTML = `<div>Ziehungen: <strong>${total}</strong></div>`+
      `<div class="small">Top Hauptzahlen: ${topA.map(x=>'<span class="badge">'+String(x.n).padStart(2,'0')+'</span>').join(' ')}</div>`;
  }

  // Tip generation
  function generateTips(mode){
    const n = Math.max(1, Math.min(200, parseInt(numTipsInput.value||'1',10)));
    tipsList.innerHTML = '';
    for (let i=0;i<n;i++){
      const tip = mode==='fair' ? fairPick() : weightedPick(mode);
      const el = document.createElement('div'); el.className='tip';
      el.innerHTML = `<div><strong>#${i+1}</strong> <span class="note">Haupt: ${tip.main.map(n=>String(n).padStart(2,'0')).join(' ')} · Euro: ${tip.euro.map(n=>String(n).padStart(2,'0')).join(' ')}</span></div>`;
      el.addEventListener('click', ()=>{ if (autoSimOnDraw.checked) sim.runDrawAnimation(tip); });
      tipsList.appendChild(el);
    }
    // Optionally run simulation for first tip
    if (autoSimOnDraw.checked && tipsList.firstChild){
      tipsList.firstChild.click();
    }
  }

  function fairPick(){
    const poolA = Array.from({length:50},(_,i)=>i+1);
    const poolB = Array.from({length:12},(_,i)=>i+1);
    const pick = (pool,k)=>{
      const out=[];
      for (let i=0;i<k;i++){ const idx=Math.floor(Math.random()*pool.length); out.push(pool.splice(idx,1)[0]); }
      return out.sort((a,b)=>a-b);
    };
    return {main:pick(poolA,5), euro:pick(poolB,2)};
  }

  function weightedPick(mode){
    // mode 'hot' or 'cold'
    const arrA = [...Array(50)].map((_,i)=>({n:i+1,f:freqA[i+1]||0}));
    const arrB = [...Array(12)].map((_,i)=>({n:i+1,f:freqB[i+1]||0}));
    const pickWeighted = (arr,k)=>{
      const maxF = Math.max(...arr.map(x=>x.f)); const minF = Math.min(...arr.map(x=>x.f));
      let weights = arr.map(x=> mode==='hot' ? (x.f - minF + 1) : (maxF - x.f + 1));
      const out = [];
      for (let i=0;i<k;i++){
        const sum = weights.reduce((a,b)=>a+b,0); let r=Math.random()*sum;
        for (let j=0;j<arr.length;j++){ r -= weights[j]; if (r<=0){ out.push(arr[j].n); weights[j]=0; break; } }
      }
      return out.sort((a,b)=>a-b);
    };
    return {main: pickWeighted(arrA,5), euro: pickWeighted(arrB,2)};
  }

  // Export all generated tips in a ZIP (simple demo: include JSON file)
  async function exportAllZip(){
    const items = [...tipsList.querySelectorAll('.tip')].map((el,i)=>{
      const txt = el.textContent || el.innerText;
      return {index:i+1,text:txt};
    });
    if (items.length===0){ alert('Keine Tipps zum Exportieren'); return; }
    const zip = new JSZip();
    zip.file('tips.json', JSON.stringify(items,null,2));
    const blob = await zip.generateAsync({type:'blob'});
    const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'tips_export.zip'; a.click();
  }

  // ----------------- Simulation implementation (2D simple physics-like) -----------------
  function createSimulator(canvas){
    const ctx = canvas.getContext('2d');
    const W = ()=>canvas.clientWidth; const H = ()=>canvas.clientHeight;
    let running = false;
    let particles = [];
    let last = 0;
    function reset(){ particles = []; for (let i=1;i<=50;i++){ particles.push(newBall(i)); } }
    function newBall(id){
      return {
        id,
        r: 14 + Math.random()*4,
        x: 40 + Math.random()*(canvas.clientWidth-80),
        y: 40 + Math.random()*(canvas.clientHeight-120),
        vx: (Math.random()-0.5)*2,
        vy: (Math.random()-0.5)*2,
        color: '#0f766e',
        picked: false
      };
    }
    function step(dt){
      // simple bounds and collisions (O(n^2) OK for 50)
      for (let p of particles){
        // apply slight drag and random jitter to mimic air turbulence
        p.vx *= 0.999; p.vy *= 0.999;
        p.vx += (Math.random()-0.5)*0.05; p.vy += (Math.random()-0.5)*0.05;
        p.x += p.vx*dt*60; p.y += p.vy*dt*60;
        // bounds
        const margin=12;
        if (p.x < margin){ p.x = margin; p.vx = Math.abs(p.vx)*0.6; }
        if (p.x > canvas.clientWidth - margin){ p.x=canvas.clientWidth-margin; p.vx = -Math.abs(p.vx)*0.6; }
        if (p.y < margin){ p.y=margin; p.vy = Math.abs(p.vy)*0.6; }
        if (p.y > canvas.clientHeight - margin){ p.y=canvas.clientHeight-margin; p.vy = -Math.abs(p.vy)*0.6; }
      }
      // collisions
      for (let i=0;i<particles.length;i++){
        for (let j=i+1;j<particles.length;j++){
          const a=particles[i], b=particles[j];
          const dx=b.x-a.x, dy=b.y-a.y; const dist=Math.hypot(dx,dy);
          const minD = a.r + b.r;
          if (dist>0 && dist < minD){
            // simple overlap resolution + exchange velocities
            const nx=dx/dist, ny=dy/dist;
            const overlap = (minD - dist)/2;
            a.x -= nx*overlap; a.y -= ny*overlap;
            b.x += nx*overlap; b.y += ny*overlap;
            // swap velocities projected
            const dvx = b.vx - a.vx, dvy = b.vy - a.vy;
            const rel = dvx*nx + dvy*ny;
            if (rel < 0){
              const impulse = rel * 0.9;
              a.vx += nx*impulse; a.vy += ny*impulse;
              b.vx -= nx*impulse; b.vy -= ny*impulse;
            }
          }
        }
      }
    }
    function draw(){
      ctx.clearRect(0,0,canvas.clientWidth,canvas.clientHeight);
      // background gradient
      const g = ctx.createLinearGradient(0,0,0,canvas.clientHeight);
      g.addColorStop(0,'rgba(10,20,25,0.4)'); g.addColorStop(1,'rgba(2,8,12,0.4)');
      ctx.fillStyle = g; ctx.fillRect(0,0,canvas.clientWidth,canvas.clientHeight);
      // draw particles
      for (let p of particles){
        ctx.beginPath(); ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
        ctx.fillStyle = p.picked ? '#ffd166' : p.color; ctx.fill();
        ctx.lineWidth = 1; ctx.strokeStyle = 'rgba(255,255,255,0.06)'; ctx.stroke();
        ctx.fillStyle = p.picked ? '#131313' : '#e6fff8'; ctx.font='12px sans-serif'; ctx.textAlign='center'; ctx.textBaseline='middle';
        ctx.fillText(String(p.id).padStart(2,'0'), p.x, p.y);
      }
    }
    // Draw animation for a given tip: mark the balls matching numbers sequentially with visual pick
    async function runDrawAnimation(tip){
      stop();
      // reset positions & randomize velocities
      reset();
      // give a short warmup
      for (let k=0;k<60;k++){ step(1/60); draw(); await tick(8); }
      // now pick balls one by one; for each desired number, nudge that ball to top and mark it
      for (const n of [...tip.main, ...tip.euro]){
        // find ball with id==n
        const p = particles.find(x=>x.id===n);
        if (!p) continue;
        // apply force toward center-top and wait until it's near top area, then mark picked
        const targetY = 40 + Math.random()*40;
        let counter=0;
        while (Math.abs(p.y - targetY) > 6 && counter < 300){
          // nudge velocity
          p.vy -= 0.06 + Math.random()*0.06;
          p.vx += (canvas.clientWidth/2 - p.x) * 0.0008;
          step(1/60); draw();
          await tick(10);
          counter++;
        }
        // mark as picked and flash
        p.picked = true;
        for (let f=0;f<20;f++){ draw(); await tick(12); }
      }
      // finish with a short pause
      await new Promise(r=>setTimeout(r,600));
    }

    function tick(ms){ return new Promise(r=>setTimeout(r,ms)); }

    function loop(t){
      if (!running) return;
      const now = performance.now();
      const dt = Math.min(0.05, (now - last)/1000 || 0.016);
      last = now;
      step(dt);
      draw();
      requestAnimationFrame(loop);
    }
    function start(){ if (running) return; running=true; last=performance.now(); requestAnimationFrame(loop); }
    function stop(){ running=false; }
    function resize(){ canvas.width = canvas.clientWidth; canvas.height = canvas.clientHeight; }
    function getParticles(){ return particles; }

    // responsive canvas
    window.addEventListener('resize', ()=>{ resize(); });
    resize(); reset();
    return {start, stop, reset, runDrawAnimation, getParticles};
  }

  // expose sim.runDrawAnimation globally for tips clickable hook
  window.simulator = sim;

})(); // end main
</script>
</body>
</html>
