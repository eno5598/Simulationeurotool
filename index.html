<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Eurojackpot Tool by EnoWeb ‚Ä¢ v6.5.2</title>

<script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js">
/* === Trommel-Physik ======================================================== */
(function(){
  // Canvas setup
  const canvas = document.getElementById('drumCanvas');
  if(!canvas) return;
  const ctx = canvas.getContext('2d');

  // Scale: 1 "Ball" = 45 mm -> map to 20 px diameter for good visuals
  const BALL_DIAM_PX = 20;
  const RADIUS = BALL_DIAM_PX/2;
  const MASS = 4; // g (used relatively, all equal mass)
  const W = canvas.width, H = canvas.height;
  const CX = W*0.5, CY = H*0.52;
  const DRUM_R = Math.min(W,H)*0.42;

  // Gate (Fangstutzen) at top-right
  const GATE_POS = {x: CX + DRUM_R*0.55, y: CY - DRUM_R*0.20};
  const GATE_R = 18;

  // Controls
  const rpmEl = document.getElementById('rpm');
  const rpmVal = document.getElementById('rpmVal');
  const dragEl = document.getElementById('drag');
  const dragVal = document.getElementById('dragVal');
  const startBtn = document.getElementById('drumStart');
  const pauseBtn = document.getElementById('drumPause');
  const resetBtn = document.getElementById('drumReset');
  const autoBtn = document.getElementById('autoDraw');
  const pickBtn = document.getElementById('pickOne');
  const outMain = document.getElementById('drumOutMain');
  const outEuro = document.getElementById('drumOutEuro');

  let running=false, rafId=null, mode='main';
  let balls=[], drawnMain=[], drawnEuro=[];
  let lastTime=0;

  function setMode(m){
    mode=m;
    document.querySelectorAll('input[name=drummode]').forEach(r=>{
      if(r.value===m) r.checked=true;
    });
    initBalls();
    renderOutputs();
  }
  document.querySelectorAll('input[name=drummode]').forEach(r=>{
    r.addEventListener('change',e=> setMode(e.target.value));
  });

  function renderOutputs(){
    function pill(n, euro=false){
      const span=document.createElement('span');
      span.className='chip'+(euro?' euro':'');
      span.textContent=n;
      return span;
    }
    outMain.innerHTML=''; drawnMain.forEach(n=> outMain.appendChild(pill(n,false)));
    outEuro.innerHTML=''; drawnEuro.forEach(n=> outEuro.appendChild(pill(n,true)));
  }

  function rng(a,b){ return a + Math.random()*(b-a); }

  function initBalls(){
    balls.length=0;
    const count = (mode==='main')? 50 : 12;
    const labels = Array.from({length:count},(_,i)=> i+1);
    // Fill with jittered circle placement
    for(let i=0;i<count;i++){
      const angle = Math.random()*Math.PI*2;
      const r = DRUM_R*0.5*rng(0.6,0.98);
      const x = CX + r*Math.cos(angle);
      const y = CY + r*Math.sin(angle);
      const speed = rng(40, 80); // px/s initial
      const dir = angle + Math.PI/2;
      balls.push({
        id: labels[i],
        x, y,
        vx: speed*Math.cos(dir),
        vy: speed*Math.sin(dir),
        r: RADIUS,
        m: MASS,
      });
    }
  }
  initBalls();

  function drawDrum(){
    // background
    ctx.clearRect(0,0,W,H);
    // drum glass
    ctx.save();
    ctx.beginPath();
    ctx.arc(CX, CY, DRUM_R, 0, Math.PI*2);
    ctx.strokeStyle='rgba(180,220,255,0.35)';
    ctx.lineWidth=8;
    ctx.stroke();
    ctx.restore();

    // gate
    ctx.beginPath();
    ctx.arc(GATE_POS.x, GATE_POS.y, GATE_R, 0, Math.PI*2);
    ctx.strokeStyle='rgba(255, 255, 255, 0.25)';
    ctx.lineWidth=2;
    ctx.stroke();
    ctx.font='12px Inter, sans-serif';
    ctx.fillStyle='rgba(255,255,255,.5)';
    ctx.fillText('Fang', GATE_POS.x-12, GATE_POS.y-18);
  }

  function drawBall(b){
    ctx.save();
    ctx.beginPath();
    ctx.arc(b.x,b.y,b.r,0,Math.PI*2);
    ctx.fillStyle = (mode==='euro') ? 'rgba(255,230,255,0.95)' : 'rgba(189,252,255,0.95)';
    ctx.fill();
    ctx.lineWidth=1.5;
    ctx.strokeStyle=(mode==='euro') ? 'rgba(255,0,234,0.5)':'rgba(0,255,255,0.45)';
    ctx.stroke();
    ctx.fillStyle='#111';
    ctx.font='bold 12px Inter, system-ui';
    const txt = String(b.id);
    const w = ctx.measureText(txt).width;
    ctx.fillText(txt, b.x - w/2, b.y + 4);
    ctx.restore();
  }

  function step(dt){
    const rpm = Number(rpmEl.value);
    rpmVal.textContent = `${rpm} U/min`;
    const drag = Number(dragEl.value);
    dragVal.textContent = drag.toFixed(3);

    // Convert rpm to angular speed (rad/s)
    const omega = rpm * 2*Math.PI / 60;

    // Swirl field to mimic "Waschmaschine"
    for(const b of balls){
      // vector from center
      const dx=b.x-CX, dy=b.y-CY;
      const dist=Math.hypot(dx,dy) || 0.0001;
      // tangential acceleration
      const tx = -dy/dist, ty = dx/dist;
      const swirl = omega*120; // tune factor to feel lively
      b.vx += tx*swirl*dt;
      b.vy += ty*swirl*dt;

      // slight radial push outward (centrifugal effect)
      const radial = omega*30;
      b.vx += (dx/dist)*radial*dt;
      b.vy += (dy/dist)*radial*dt;

      // air drag (depends on "Styropor" ‚Äì light, so noticeable)
      b.vx *= (1 - drag);
      b.vy *= (1 - drag);

      // integrate
      b.x += b.vx*dt;
      b.y += b.vy*dt;

      // wall collision (circle)
      const vx=b.vx, vy=b.vy;
      const fromC = Math.hypot(b.x-CX,b.y-CY);
      const maxR = DRUM_R - b.r - 4;
      if(fromC>maxR){
        // project back on boundary
        const nx = (b.x-CX)/fromC, ny=(b.y-CY)/fromC;
        b.x = CX + nx*maxR;
        b.y = CY + ny*maxR;
        // reflect velocity on normal with little energy loss (Styropor is bouncy but light)
        const vn = vx*nx + vy*ny;
        const vt_x = vx - vn*nx, vt_y = vy - vn*ny;
        const restitution = 0.85;
        b.vx = vt_x - restitution*vn*nx;
        b.vy = vt_y - restitution*vn*ny;
      }
    }

    // ball-ball collisions (elastic, equal mass)
    for(let i=0;i<balls.length;i++){
      for(let j=i+1;j<balls.length;j++){
        const a=balls[i], b=balls[j];
        const dx=b.x-a.x, dy=b.y-a.y;
        const dist2 = dx*dx+dy*dy;
        const rsum=a.r+b.r;
        if(dist2 < rsum*rsum){
          const dist = Math.sqrt(dist2)||0.0001;
          const nx=dx/dist, ny=dy/dist;
          const p = (a.vx - b.vx)*nx + (a.vy - b.vy)*ny;
          if(p>0) continue;
          const imp = (-2*p)/(1+1); // equal mass
          a.vx += imp*nx;
          a.vy += imp*ny;
          b.vx -= imp*nx;
          b.vy -= imp*ny;
          // separate
          const overlap = (rsum - dist)/2;
          a.x -= nx*overlap; a.y -= ny*overlap;
          b.x += nx*overlap; b.y += ny*overlap;
        }
      }
    }
  }

  function draw(){
    drawDrum();
    for(const b of balls) drawBall(b);
  }

  function loop(ts){
    if(!running){ return; }
    const t = ts*0.001;
    const dt = Math.min(0.033, lastTime? (t-lastTime): 0.016);
    lastTime = t;
    step(dt);
    draw();
    rafId = requestAnimationFrame(loop);
  }

  function start(){ if(!running){ running=true; lastTime=0; rafId=requestAnimationFrame(loop); } }
  function pause(){ running=false; if(rafId) cancelAnimationFrame(rafId); rafId=null; }
  function reset(){
    pause();
    drawnMain.length=0; drawnEuro.length=0;
    renderOutputs();
    initBalls();
    draw();
  }

  startBtn.addEventListener('click', start);
  pauseBtn.addEventListener('click', pause);
  resetBtn.addEventListener('click', reset);

  function removeBallToOutput(ball){
    // remove from balls
    balls = balls.filter(b=> b!==ball);
    // append to output
    if(mode==='main'){
      drawnMain.push(ball.id);
      drawnMain.sort((a,b)=>a-b);
    }else{
      drawnEuro.push(ball.id);
      drawnEuro.sort((a,b)=>a-b);
    }
    renderOutputs();
  }

  function tryCatchOne(){
    // If a ball is inside the gate circle and slow enough, catch it
    let candidate=null, best=1e9;
    for(const b of balls){
      const d = Math.hypot(b.x-GATE_POS.x, b.y-GATE_POS.y);
      if(d < GATE_R - 2){
        const sp = Math.hypot(b.vx,b.vy);
        if(sp < best){ best = sp; candidate=b; }
      }
    }
    if(candidate){
      removeBallToOutput(candidate);
      return true;
    }
    return false;
  }

  pickBtn.addEventListener('click', ()=>{
    // Try immediate catch; fallback: pick random near top
    if(tryCatchOne()) return;
    const nearTop = balls.filter(b=> b.y < CY - DRUM_R*0.2);
    const pick = (nearTop.length? nearTop : balls);
    if(pick.length){
      const b = pick[Math.floor(Math.random()*pick.length)];
      removeBallToOutput(b);
    }
  });

  async function autoDrawSequence(){
    // Main numbers (5), then switch mode and draw 2 Euros
    setMode('main');
    start();
    await sleep(1200);
    while(drawnMain.length<5){
      // let them tumble a bit
      await sleep(1200);
      // try to catch one, retry if needed
      let ok=false, tries=0;
      while(!ok && tries<6){
        ok = tryCatchOne();
        if(!ok){ await sleep(600); tries++; }
      }
      if(!ok && balls.length){ // hard fallback
        removeBallToOutput(balls[Math.floor(Math.random()*balls.length)]);
      }
    }
    // switch to Euro
    setMode('euro');
    start();
    await sleep(1000);
    while(drawnEuro.length<2){
      await sleep(1200);
      let ok=false, tries=0;
      while(!ok && tries<6){
        ok = tryCatchOne();
        if(!ok){ await sleep(600); tries++; }
      }
      if(!ok && balls.length){
        removeBallToOutput(balls[Math.floor(Math.random()*balls.length)]);
      }
    }
    // done
    pause();
  }
  autoBtn.addEventListener('click', autoDrawSequence);

  // initial static draw
  draw();

  // integrate with existing animateSelection to visualize picks on Map, if present
  window.__drum_get_result = function(){
    return { main: drawnMain.slice(0,5).sort((a,b)=>a-b), euro: drawnEuro.slice(0,2).sort((a,b)=>a-b) };
  };
})();

</script>
<script src="https://cdn.jsdelivr.net/npm/chart.js">
/* === Trommel-Physik ======================================================== */
(function(){
  // Canvas setup
  const canvas = document.getElementById('drumCanvas');
  if(!canvas) return;
  const ctx = canvas.getContext('2d');

  // Scale: 1 "Ball" = 45 mm -> map to 20 px diameter for good visuals
  const BALL_DIAM_PX = 20;
  const RADIUS = BALL_DIAM_PX/2;
  const MASS = 4; // g (used relatively, all equal mass)
  const W = canvas.width, H = canvas.height;
  const CX = W*0.5, CY = H*0.52;
  const DRUM_R = Math.min(W,H)*0.42;

  // Gate (Fangstutzen) at top-right
  const GATE_POS = {x: CX + DRUM_R*0.55, y: CY - DRUM_R*0.20};
  const GATE_R = 18;

  // Controls
  const rpmEl = document.getElementById('rpm');
  const rpmVal = document.getElementById('rpmVal');
  const dragEl = document.getElementById('drag');
  const dragVal = document.getElementById('dragVal');
  const startBtn = document.getElementById('drumStart');
  const pauseBtn = document.getElementById('drumPause');
  const resetBtn = document.getElementById('drumReset');
  const autoBtn = document.getElementById('autoDraw');
  const pickBtn = document.getElementById('pickOne');
  const outMain = document.getElementById('drumOutMain');
  const outEuro = document.getElementById('drumOutEuro');

  let running=false, rafId=null, mode='main';
  let balls=[], drawnMain=[], drawnEuro=[];
  let lastTime=0;

  function setMode(m){
    mode=m;
    document.querySelectorAll('input[name=drummode]').forEach(r=>{
      if(r.value===m) r.checked=true;
    });
    initBalls();
    renderOutputs();
  }
  document.querySelectorAll('input[name=drummode]').forEach(r=>{
    r.addEventListener('change',e=> setMode(e.target.value));
  });

  function renderOutputs(){
    function pill(n, euro=false){
      const span=document.createElement('span');
      span.className='chip'+(euro?' euro':'');
      span.textContent=n;
      return span;
    }
    outMain.innerHTML=''; drawnMain.forEach(n=> outMain.appendChild(pill(n,false)));
    outEuro.innerHTML=''; drawnEuro.forEach(n=> outEuro.appendChild(pill(n,true)));
  }

  function rng(a,b){ return a + Math.random()*(b-a); }

  function initBalls(){
    balls.length=0;
    const count = (mode==='main')? 50 : 12;
    const labels = Array.from({length:count},(_,i)=> i+1);
    // Fill with jittered circle placement
    for(let i=0;i<count;i++){
      const angle = Math.random()*Math.PI*2;
      const r = DRUM_R*0.5*rng(0.6,0.98);
      const x = CX + r*Math.cos(angle);
      const y = CY + r*Math.sin(angle);
      const speed = rng(40, 80); // px/s initial
      const dir = angle + Math.PI/2;
      balls.push({
        id: labels[i],
        x, y,
        vx: speed*Math.cos(dir),
        vy: speed*Math.sin(dir),
        r: RADIUS,
        m: MASS,
      });
    }
  }
  initBalls();

  function drawDrum(){
    // background
    ctx.clearRect(0,0,W,H);
    // drum glass
    ctx.save();
    ctx.beginPath();
    ctx.arc(CX, CY, DRUM_R, 0, Math.PI*2);
    ctx.strokeStyle='rgba(180,220,255,0.35)';
    ctx.lineWidth=8;
    ctx.stroke();
    ctx.restore();

    // gate
    ctx.beginPath();
    ctx.arc(GATE_POS.x, GATE_POS.y, GATE_R, 0, Math.PI*2);
    ctx.strokeStyle='rgba(255, 255, 255, 0.25)';
    ctx.lineWidth=2;
    ctx.stroke();
    ctx.font='12px Inter, sans-serif';
    ctx.fillStyle='rgba(255,255,255,.5)';
    ctx.fillText('Fang', GATE_POS.x-12, GATE_POS.y-18);
  }

  function drawBall(b){
    ctx.save();
    ctx.beginPath();
    ctx.arc(b.x,b.y,b.r,0,Math.PI*2);
    ctx.fillStyle = (mode==='euro') ? 'rgba(255,230,255,0.95)' : 'rgba(189,252,255,0.95)';
    ctx.fill();
    ctx.lineWidth=1.5;
    ctx.strokeStyle=(mode==='euro') ? 'rgba(255,0,234,0.5)':'rgba(0,255,255,0.45)';
    ctx.stroke();
    ctx.fillStyle='#111';
    ctx.font='bold 12px Inter, system-ui';
    const txt = String(b.id);
    const w = ctx.measureText(txt).width;
    ctx.fillText(txt, b.x - w/2, b.y + 4);
    ctx.restore();
  }

  function step(dt){
    const rpm = Number(rpmEl.value);
    rpmVal.textContent = `${rpm} U/min`;
    const drag = Number(dragEl.value);
    dragVal.textContent = drag.toFixed(3);

    // Convert rpm to angular speed (rad/s)
    const omega = rpm * 2*Math.PI / 60;

    // Swirl field to mimic "Waschmaschine"
    for(const b of balls){
      // vector from center
      const dx=b.x-CX, dy=b.y-CY;
      const dist=Math.hypot(dx,dy) || 0.0001;
      // tangential acceleration
      const tx = -dy/dist, ty = dx/dist;
      const swirl = omega*120; // tune factor to feel lively
      b.vx += tx*swirl*dt;
      b.vy += ty*swirl*dt;

      // slight radial push outward (centrifugal effect)
      const radial = omega*30;
      b.vx += (dx/dist)*radial*dt;
      b.vy += (dy/dist)*radial*dt;

      // air drag (depends on "Styropor" ‚Äì light, so noticeable)
      b.vx *= (1 - drag);
      b.vy *= (1 - drag);

      // integrate
      b.x += b.vx*dt;
      b.y += b.vy*dt;

      // wall collision (circle)
      const vx=b.vx, vy=b.vy;
      const fromC = Math.hypot(b.x-CX,b.y-CY);
      const maxR = DRUM_R - b.r - 4;
      if(fromC>maxR){
        // project back on boundary
        const nx = (b.x-CX)/fromC, ny=(b.y-CY)/fromC;
        b.x = CX + nx*maxR;
        b.y = CY + ny*maxR;
        // reflect velocity on normal with little energy loss (Styropor is bouncy but light)
        const vn = vx*nx + vy*ny;
        const vt_x = vx - vn*nx, vt_y = vy - vn*ny;
        const restitution = 0.85;
        b.vx = vt_x - restitution*vn*nx;
        b.vy = vt_y - restitution*vn*ny;
      }
    }

    // ball-ball collisions (elastic, equal mass)
    for(let i=0;i<balls.length;i++){
      for(let j=i+1;j<balls.length;j++){
        const a=balls[i], b=balls[j];
        const dx=b.x-a.x, dy=b.y-a.y;
        const dist2 = dx*dx+dy*dy;
        const rsum=a.r+b.r;
        if(dist2 < rsum*rsum){
          const dist = Math.sqrt(dist2)||0.0001;
          const nx=dx/dist, ny=dy/dist;
          const p = (a.vx - b.vx)*nx + (a.vy - b.vy)*ny;
          if(p>0) continue;
          const imp = (-2*p)/(1+1); // equal mass
          a.vx += imp*nx;
          a.vy += imp*ny;
          b.vx -= imp*nx;
          b.vy -= imp*ny;
          // separate
          const overlap = (rsum - dist)/2;
          a.x -= nx*overlap; a.y -= ny*overlap;
          b.x += nx*overlap; b.y += ny*overlap;
        }
      }
    }
  }

  function draw(){
    drawDrum();
    for(const b of balls) drawBall(b);
  }

  function loop(ts){
    if(!running){ return; }
    const t = ts*0.001;
    const dt = Math.min(0.033, lastTime? (t-lastTime): 0.016);
    lastTime = t;
    step(dt);
    draw();
    rafId = requestAnimationFrame(loop);
  }

  function start(){ if(!running){ running=true; lastTime=0; rafId=requestAnimationFrame(loop); } }
  function pause(){ running=false; if(rafId) cancelAnimationFrame(rafId); rafId=null; }
  function reset(){
    pause();
    drawnMain.length=0; drawnEuro.length=0;
    renderOutputs();
    initBalls();
    draw();
  }

  startBtn.addEventListener('click', start);
  pauseBtn.addEventListener('click', pause);
  resetBtn.addEventListener('click', reset);

  function removeBallToOutput(ball){
    // remove from balls
    balls = balls.filter(b=> b!==ball);
    // append to output
    if(mode==='main'){
      drawnMain.push(ball.id);
      drawnMain.sort((a,b)=>a-b);
    }else{
      drawnEuro.push(ball.id);
      drawnEuro.sort((a,b)=>a-b);
    }
    renderOutputs();
  }

  function tryCatchOne(){
    // If a ball is inside the gate circle and slow enough, catch it
    let candidate=null, best=1e9;
    for(const b of balls){
      const d = Math.hypot(b.x-GATE_POS.x, b.y-GATE_POS.y);
      if(d < GATE_R - 2){
        const sp = Math.hypot(b.vx,b.vy);
        if(sp < best){ best = sp; candidate=b; }
      }
    }
    if(candidate){
      removeBallToOutput(candidate);
      return true;
    }
    return false;
  }

  pickBtn.addEventListener('click', ()=>{
    // Try immediate catch; fallback: pick random near top
    if(tryCatchOne()) return;
    const nearTop = balls.filter(b=> b.y < CY - DRUM_R*0.2);
    const pick = (nearTop.length? nearTop : balls);
    if(pick.length){
      const b = pick[Math.floor(Math.random()*pick.length)];
      removeBallToOutput(b);
    }
  });

  async function autoDrawSequence(){
    // Main numbers (5), then switch mode and draw 2 Euros
    setMode('main');
    start();
    await sleep(1200);
    while(drawnMain.length<5){
      // let them tumble a bit
      await sleep(1200);
      // try to catch one, retry if needed
      let ok=false, tries=0;
      while(!ok && tries<6){
        ok = tryCatchOne();
        if(!ok){ await sleep(600); tries++; }
      }
      if(!ok && balls.length){ // hard fallback
        removeBallToOutput(balls[Math.floor(Math.random()*balls.length)]);
      }
    }
    // switch to Euro
    setMode('euro');
    start();
    await sleep(1000);
    while(drawnEuro.length<2){
      await sleep(1200);
      let ok=false, tries=0;
      while(!ok && tries<6){
        ok = tryCatchOne();
        if(!ok){ await sleep(600); tries++; }
      }
      if(!ok && balls.length){
        removeBallToOutput(balls[Math.floor(Math.random()*balls.length)]);
      }
    }
    // done
    pause();
  }
  autoBtn.addEventListener('click', autoDrawSequence);

  // initial static draw
  draw();

  // integrate with existing animateSelection to visualize picks on Map, if present
  window.__drum_get_result = function(){
    return { main: drawnMain.slice(0,5).sort((a,b)=>a-b), euro: drawnEuro.slice(0,2).sort((a,b)=>a-b) };
  };
})();

</script>
<link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">

<style>
  :root{ --cy:#00fff0; --mag:#ff00ea; --ink:#eaf7ff; --bg:#060712; --ok:#39ff88; --bad:#ff6b94; }
  body{background:radial-gradient(900px 700px at -10% -10%, rgba(0,255,240,.12), transparent 60%), radial-gradient(900px 700px at 110% -10%, rgba(255,0,234,.12), transparent 60%), var(--bg); color:var(--ink); font-family:Inter, ui-sans-serif, system-ui;}
  .title{background:linear-gradient(90deg,var(--cy),var(--mag)); -webkit-background-clip:text; color:transparent; font-weight:900}
  .glass{background:rgba(15,18,40,.78); backdrop-filter: blur(14px); border:1px solid rgba(0,255,255,.18); border-radius:14px; padding:14px; box-shadow: 0 12px 40px rgba(0,0,0,.45);}
  .nav-btn{display:flex;flex-direction:column;align-items:center;justify-content:center;gap:6px; min-width:90px;height:78px;padding:8px 10px;border-radius:16px;background:linear-gradient(180deg,rgba(18,24,50,.9),rgba(14,18,36,.9)); border:1px solid rgba(255,255,255,.08); box-shadow: inset 0 0 0 1px rgba(255,255,255,.06), 0 8px 22px rgba(0,0,0,.4);}
  .nav-btn.active{outline:2px solid rgba(255,255,255,.15); box-shadow:0 0 20px rgba(0,255,255,.35), inset 0 0 0 1px rgba(255,255,255,.1);}
  .chip{display:inline-flex;align-items:center;justify-content:center;min-width:32px;height:32px;border-radius:10px;margin:4px;font-weight:800;font-size:.9rem;color:#bdfcff;background:linear-gradient(180deg,#0e1530,#15204a);border:1px solid rgba(0,255,255,.25);}
  .chip.euro{color:#ffe6ff;background:linear-gradient(180deg,#1c1433,#1c2b53);border-color:rgba(255,0,234,.3)}
  .chip.sel{background:linear-gradient(180deg,rgba(0,255,240,.25),rgba(0,255,240,.05)); box-shadow:0 0 16px rgba(0,255,240,.35), inset 0 0 0 1px rgba(0,255,255,.45); }
  .badge{background:rgba(255,255,255,.06); border:1px solid rgba(140,170,255,.22); border-radius:999px; padding:.15rem .5rem; font-size:.72rem;}
  .counter{padding:.2rem .55rem;border-radius:999px;font-weight:700}
  .counter.red{background:#3a1520;border:1px solid var(--bad)}
  .counter.green{background:#153a29;border:1px solid var(--ok)}
  .btn{display:inline-flex;align-items:center;justify-content:center;gap:.5rem;height:44px;padding:0 12px;border-radius:12px;border:1px solid rgba(255,255,255,.08);font-weight:700}
  .btn--green{background:#15803d;color:#fff;}
  .btn--amber{background:#b45309;color:#fff;}
  .btn--gray{background:#374151;color:#fff;}
  .btn:hover{filter:brightness(1.1)}
  .file-label{cursor:pointer; padding:10px 14px; border-radius:12px; border:1px solid rgba(255,255,255,.08); background:linear-gradient(180deg,rgba(18,24,50,.9),rgba(14,18,36,.9)); display:inline-flex; gap:8px; align-items:center;}
  .file-input{display:none}
</style>
</head>
<body class="p-5">
  <h1 class="title text-3xl md:text-4xl mb-4">Eurojackpot Tool by EnoWeb</h1>

  <div class="flex justify-center flex-wrap gap-3 mb-6">
    <button type="button" onclick="tab('archiv', this)" class="nav-btn active" id="btn-archiv"><div>üìÇ</div><span>Archiv</span></button>
    <button type="button" onclick="tab('map', this)" class="nav-btn" id="btn-map"><div>üó∫Ô∏è</div><span>Map</span></button>
    <button type="button" onclick="tab('gen', this)" class="nav-btn" id="btn-gen"><div>‚ö°</div><span>Generieren</span></button>
    <button type="button" onclick="tab('ana', this)" class="nav-btn" id="btn-ana"><div>üìä</div><span>Analyse</span></button>
    <button type="button" onclick="tab('fav', this)" class="nav-btn" id="btn-fav"><div>‚≠ê</div><span>Favoriten</span></button>
    <button type="button" onclick="tab('drum', this)" class="nav-btn" id="btn-drum"><div>üé±</div><span>Trommel</span></button>
  </div>

  <!-- ARCHIV -->
  <div id="v-archiv" class="glass">
    <h2 class="text-xl font-bold mb-2">üìÇ Archiv</h2>
    <p id="statusText" class="text-sm mb-2">Noch kein Archiv geladen.</p>

    <div class="glass mb-3">
      <div class="font-semibold mb-2">Automatisches Laden</div>
      <div class="flex flex-col md:flex-row gap-2">
        <input id="archiveUrl" class="bg-gray-900 p-2 rounded flex-1" value="https://www.lotto-bayern.de/static/gamebroker_2/de/download_files/archiv_eurojackpot.zip">
        <button type="button" id="loadLatestBtn" class="btn btn--green">üì• Neueste laden</button>
        <button type="button" id="forceDlBtn" class="btn btn--amber">‚¨áÔ∏è ZIP speichern</button>
        <a id="directDl" class="btn btn--gray" target="_blank" rel="noopener">üîó Direktlink</a>
      </div>
      <p class="text-xs text-gray-300 mt-2">‚ÄûZIP speichern‚Äú l√§dt √ºber mehrere Proxys und speichert lokal. ‚ÄûDirektlink‚Äú √∂ffnet die Original-URL.</p>
    </div>

    <div class="glass mb-3">
      <div class="font-semibold mb-2">Manuell laden</div>
      <label class="file-label">
        üìÑ Datei ausw√§hlen
        <input type="file" id="zipInput" class="file-input" accept=".zip,.txt,.csv">
      </label>
      <span id="fileName" class="ml-2 text-sm opacity-80">Keine Datei ausgew√§hlt</span>
      <div class="badge mt-2">Tipp: ZIP/TXT/CSV per Drag & Drop auf die Seite ziehen.</div>
    </div>

    <div class="grid grid-cols-2 md:grid-cols-4 gap-2 text-center">
      <div><div class="text-sm text-gray-300">Ziehungen</div><div id="kpiCount" class="font-bold">‚Äì</div></div>
      <div><div class="text-sm text-gray-300">Von</div><div id="kpiFrom" class="font-bold">‚Äì</div></div>
      <div><div class="text-sm text-gray-300">Bis</div><div id="kpiTo" class="font-bold">‚Äì</div></div>
      <div><div class="text-sm text-gray-300">Aktualit√§t</div><div id="kpiFresh" class="font-bold">‚Äì</div></div>
    </div>
    <p id="freshHint" class="text-xs opacity-80 mt-2"></p>
  </div>

  <!-- MAP -->
  <div id="v-map" class="glass hidden">
    <div class="flex items-center justify-between mb-1">
      <h2 class="text-xl font-bold">üó∫ Map</h2>
      <div class="badge">Live‚ÄëAnimation</div>
    </div>
    <div class="mb-1 flex items-center justify-between">
      <div class="badge">Hauptzahlen 1‚Äì50</div><div id="progress" class="badge">Bereit</div>
    </div>
    <div id="mapMain" class="flex flex-wrap relative"></div>
    <div class="mt-3 badge">Eurozahlen 1‚Äì12</div>
    <div id="mapEuro" class="flex flex-wrap relative"></div>
  </div>

  <!-- GENERIEREN -->
  <div id="v-gen" class="glass hidden">
    <h2 class="text-xl font-bold mb-2">‚ö° Generieren</h2>
    <div class="grid grid-cols-1 md:grid-cols-3 gap-3">
      <div>
        <label class="text-sm text-gray-300">Modus</label>
        <select id="modus" class="bg-gray-900 p-2 rounded w-full">
          <option value="never">Nie gezogene</option>
          <option value="last100">Letzte 100 ‚Äì Frequenzmuster</option>
          <option value="hot">Hot Paare & Triples</option>
          <option value="groups">5er-Gruppen + W√ºnsche</option>
          <option value="complex">Komplex (Simulated Annealing)</option>
          <option value="runs">Folgen‚ÄëZahlen</option>
        </select>
      </div>
      <div>
        <label class="text-sm text-gray-300">Anzahl Kombinationen</label>
        <input type="number" id="kombis" value="5" min="1" max="25" class="bg-gray-900 p-2 rounded w-full">
      </div>
      <div class="grid grid-cols-3 gap-2">
        <button type="button" id="generateBtn" class="btn btn--green">‚ö° Generieren</button>
        <button type="button" id="analyseAllBtn" class="btn btn--amber">üìä Alle analysieren</button>
        <button type="button" id="clearGeneratedBtn" class="btn btn--gray">üóëÔ∏è Alle l√∂schen</button>
      </div>
    </div>

    <div id="groupUI" class="mt-4 hidden">
      <div class="mb-1 text-sm text-gray-300 flex items-center gap-3">
        <span>Gruppen: exakt 5 erforderlich</span>
        <span id="mainCounter" class="counter red">0/5</span>
        <span id="euroCounter" class="counter red hidden">0/2</span>
      </div>
      <div id="groupControls" class="grid grid-cols-1 md:grid-cols-2 gap-2"></div>
      <div class="mt-1 flex items-center justify-between">
        <div class="badge">Eurozahlen (optional, 0 oder 2)</div>
        <label class="inline-flex items-center gap-2">
          <input id="useEuro" type="checkbox"><span class="text-sm">Euro ber√ºcksichtigen</span>
        </label>
      </div>
      <div id="euroControls" class="grid grid-cols-2 gap-2 mt-1 hidden"></div>
      <div id="groupError" class="bg-red-900/40 border border-red-400 text-red-200 rounded px-2 py-1 hidden mt-2"></div>
    </div>

    <pre id="liveOutput" class="font-mono bg-black/70 p-3 mt-3 rounded h-44 overflow-auto text-green-300"></pre>
    <div id="cards" class="mt-3"></div>
  </div>

  <!-- ANALYSE -->
  <div id="v-ana" class="glass hidden">
    <h2 class="text-xl font-bold mb-2">üìä Analyse</h2>
    <div class="grid grid-cols-2 md:grid-cols-4 gap-2 mb-3">
      <div class="glass"><div class="text-xs text-gray-300">Meistgezogen (Top 5)</div><div id="kpiTop" class="font-bold"></div></div>
      <div class="glass"><div class="text-xs text-gray-300">Selten (Bottom 5)</div><div id="kpiLow" class="font-bold"></div></div>
      <div class="glass"><div class="text-xs text-gray-300">Hot (letzte 20)</div><div id="kpiHot" class="font-bold"></div></div>
      <div class="glass"><div class="text-xs text-gray-300">Top‚ÄëPaare</div><div id="kpiPairs" class="font-bold"></div></div>
    </div>
    <canvas id="chartMain" class="w-full h-60 mb-4"></canvas>
    <canvas id="chartEuro" class="w-full h-56"></canvas>
    <div id="analysisBox" class="mt-3 text-sm"></div>
  </div>

  
  <!-- TROMMEL -->
  <div id="v-drum" class="glass hidden">
    <div class="flex items-center justify-between mb-2">
      <h2 class="text-xl font-bold">üé± Ziehung ‚Äì Trommel</h2>
      <div class="badge">Styropor ¬∑ √ò 4,5 cm ¬∑ 4 g</div>
    </div>

    <div class="grid grid-cols-1 md:grid-cols-3 gap-3">
      <div class="md:col-span-2">
        <canvas id="drumCanvas" width="680" height="520" class="w-full rounded border border-white/10 bg-black/30"></canvas>
      </div>
      <div class="space-y-2">
        <div class="glass">
          <div class="font-semibold mb-1">Modus</div>
          <div class="flex gap-2 flex-wrap">
            <label class="inline-flex items-center gap-2"><input type="radio" name="drummode" value="main" checked> <span>Hauptzahlen (1‚Äì50)</span></label>
            <label class="inline-flex items-center gap-2"><input type="radio" name="drummode" value="euro"> <span>Eurozahlen (1‚Äì12)</span></label>
          </div>
        </div>
        <div class="glass">
          <div class="font-semibold mb-1">Steuerung</div>
          <div class="flex gap-2 flex-wrap">
            <button type="button" class="btn btn--green" id="drumStart">‚ñ∂Ô∏è Start</button>
            <button type="button" class="btn btn--gray" id="drumPause">‚è∏Ô∏è Pause</button>
            <button type="button" class="btn btn--amber" id="drumReset">üîÑ Reset</button>
          </div>
          <div class="mt-2 text-sm">
            <label class="block mb-1">Drehzahl <span id="rpmVal" class="badge">40 U/min</span></label>
            <input id="rpm" type="range" min="10" max="90" step="1" value="40" class="w-full">
          </div>
          <div class="mt-2 text-sm">
            <label class="block mb-1">Luftwiderstand <span id="dragVal" class="badge">0.015</span></label>
            <input id="drag" type="range" min="0" max="0.06" step="0.005" value="0.015" class="w-full">
          </div>
        </div>
        <div class="glass">
          <div class="font-semibold mb-1">Ziehung</div>
          <div class="text-sm opacity-80">Es werden automatisch 5 Hauptzahlen gezogen, danach (optional) die 2 Eurozahlen.</div>
          <div class="mt-2 flex gap-2 flex-wrap">
            <button type="button" class="btn btn--green" id="autoDraw">üé¨ Auto‚ÄëZiehung</button>
            <button type="button" class="btn btn--gray" id="pickOne">üéüÔ∏è 1 Kugel fangen</button>
          </div>
          <div class="mt-2">
            <div class="badge">Gezogene Hauptzahlen</div>
            <div id="drumOutMain" class="mt-1 flex flex-wrap"></div>
            <div class="badge mt-2">Gezogene Eurozahlen</div>
            <div id="drumOutEuro" class="mt-1 flex flex-wrap"></div>
          </div>
        </div>
      </div>
    </div>
  </div>


  <!-- FAVORITEN -->
  <div id="v-fav" class="glass hidden">
    <h2 class="text-xl font-bold mb-2">‚≠ê Favoriten</h2>
    <div class="flex gap-2 flex-wrap mb-3">
      <input id="favSearch" placeholder="Suche‚Ä¶" class="bg-gray-900 p-2 rounded flex-1 min-w-[180px]">
      <button type="button" id="favExport" class="btn btn--gray">Export</button>
      <button type="button" id="favImport" class="btn btn--gray">Import</button>
      <button type="button" id="favCSV" class="btn btn--gray">CSV</button>
      <button type="button" id="favClear" class="btn btn--gray">Leeren</button>
    </div>
    <div id="favoritesBox" class="space-y-2"></div>
  </div>

<script>
const $ = s => document.querySelector(s);
const $$ = s => Array.from(document.querySelectorAll(s));
const sleep = ms => new Promise(r=>setTimeout(r,ms));
const sum = a => a.reduce((s,v)=>s+v,0);

/* === "Neueste Referenz" f√ºr Aktualit√§t ===================================== */
const LATEST_REF_KEY = 'ej_latest_ref_date_v1'; // ISO yyyy-mm-dd
let latestRefDate = localStorage.getItem(LATEST_REF_KEY) || null;

/* === UI Grundfunktionen ==================================================== */
function tab(name, btn){
  ['archiv','map','gen','ana','fav','drum'].forEach(n=>$('#v-'+n).classList.add('hidden'));
  $('#v-'+name).classList.remove('hidden');
  $$('.nav-btn').forEach(b=>b.classList.remove('active'));
  if(btn) btn.classList.add('active');
  if(name==='fav') renderFavs();
}

function renderMap(){
  const m=$('#mapMain'); m.innerHTML='';
  for(let i=1;i<=50;i++){ const d=document.createElement('div'); d.className='chip'; d.textContent=i; d.dataset.n=i; m.appendChild(d); }
  const e=$('#mapEuro'); e.innerHTML='';
  for(let i=1;i<=12;i++){ const d=document.createElement('div'); d.className='chip euro'; d.textContent=i; d.dataset.n=i; e.appendChild(d); }
  $('#progress').textContent='Bereit';
}
renderMap();
function clearMap(){ $$('#mapMain .chip, #mapEuro .chip').forEach(c=>c.classList.remove('sel')); }
async function animateSelection(main,euro){
  tab('map',$('#btn-map')); clearMap(); $('#progress').textContent='Tippt‚Ä¶';
  for(const n of main){ const el=$(`#mapMain .chip[data-n="${n}"]`); if(el){ el.classList.add('sel'); await sleep(120);} }
  for(const n of euro){ const el=$(`#mapEuro .chip[data-n="${n}"]`); if(el){ el.classList.add('sel'); await sleep(120);} }
  $('#progress').textContent='Fertig';
}

/* === State ================================================================= */
let draws=[]; let freqMain=Array(51).fill(0), freqEuro=Array(13).fill(0); let lastSeen=Array(51).fill(null), lastSeenE=Array(13).fill(null);
let generated=[];
let favorites = JSON.parse(localStorage.getItem("ej_favs_v1")||"[]");
const ARCH_KEY='ej_archive_v1';

/* === KPIs & Aktualit√§t ===================================================== */
function computeFreshnessLabel(endIso){
  // 1) Vergleich zu "latestRefDate", falls vorhanden
  if(latestRefDate){
    const end = new Date(endIso); const ref = new Date(latestRefDate);
    if(end < ref){ // √§lter als zuletzt bekannte "neueste"
      const daysBehind = Math.round((ref - end)/86400000);
      return `veraltet (‚àí${daysBehind} Tage gegen√ºber neuestem: ${latestRefDate})`;
    }
  }
  // 2) Fallback: Vergleich zu heute
  const last=new Date(endIso);
  const days=Math.max(0, Math.round((Date.now()-last.getTime())/86400000));
  if(days<=14) return 'aktuell';
  if(days<=60) return `ok (${days} Tage alt)`;
  return `veraltet (${days} Tage alt)`;
}

function setKPIs(){
  if(!draws.length){
    $('#kpiCount').textContent='‚Äì'; $('#kpiFrom').textContent='‚Äì'; $('#kpiTo').textContent='‚Äì'; $('#kpiFresh').textContent='‚Äì';
    $('#freshHint').textContent=''; return;
  }
  $('#kpiCount').textContent=draws.length;
  $('#kpiFrom').textContent=draws[0].date;
  $('#kpiTo').textContent=draws.at(-1).date;
  const label = computeFreshnessLabel(draws.at(-1).date);
  $('#kpiFresh').textContent = label;
  $('#freshHint').textContent = latestRefDate ? `Neuestes Referenz-Ende: ${latestRefDate}` : '';
}

/* === Archiv Laden/Parsen =================================================== */
async function ensureJSZip(){
  if (window.JSZip) return true;
  const cdns = [
    'https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js',
    'https://unpkg.com/jszip@3.10.1/dist/jszip.min.js',
    'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js'
  ];
  for(const src of cdns){
    try{
      await new Promise((resolve, reject)=>{
        const s=document.createElement('script');
        s.src=src; s.async=true;
        s.onload=()=>resolve(); s.onerror=()=>reject();
        document.head.appendChild(s);
      });
      if(window.JSZip) return true;
    }catch{}
  }
  return false;
}

async function fetchWithProxies(url){
  const trials=[
    url,
    'https://cors.isomorphic-git.org/'+url,
    'https://api.allorigins.win/raw?url='+encodeURIComponent(url),
    'https://thingproxy.freeboard.io/fetch/'+url,
    'https://corsproxy.io/?'+encodeURIComponent(url)
  ];
  let last=null;
  for(const u of trials){
    try{
      const res=await fetch(u);
      if(!res.ok) throw new Error('HTTP '+res.status);
      const ct=res.headers.get('content-type')||'';
      if(ct.includes('zip') || u.endsWith('.zip')){
        const ok = await ensureJSZip();
        if(!ok) throw new Error('JSZip nicht verf√ºgbar (CDN blockiert).');
        const blob=await res.blob();
        const zip=await JSZip.loadAsync(blob); const entries=Object.values(zip.files);
        let entry=entries.find(f=>/\.(txt|csv)$/i.test(f.name) && /eurojackpot/i.test(f.name)) || entries.find(f=>/\.(txt|csv)$/i.test(f.name));
        if(!entry) throw new Error('ZIP ohne TXT/CSV.');
        const text=await entry.async('string'); return text;
      }else{
        return await res.text();
      }
    }catch(e){ last=e; }
  }
  throw last||new Error('Download fehlgeschlagen');
}

function parseArchiveText(txt, source='manual'){
  try{
    txt=txt.replace(/^\uFEFF/,'');
    const lines = txt.replace(/\r\n?/g,'\n').split('\n').map(l=>l.trim()).filter(Boolean);
    const cleaned = lines.filter(l => (l.match(/\d+/g)||[]).length >= 7);
    function iso(y,m,d){ const dt=new Date(+y, +m-1, +d); return isNaN(dt)? null : dt.toISOString().slice(0,10); }
    const regDMY=/^(\d{1,2})[.\-\/](\d{1,2})[.\-\/](\d{2,4})$/, regYMD=/^(\d{4})[.\-\/](\d{1,2})[.\-\/](\d{1,2})$/;
    function parseLine(line){
      const t=line.split(/;|,|\t|\s+/).filter(Boolean); let date=null,rest=[];
      if(t.length&&regDMY.test(t[0])){const m=t[0].match(regDMY); date=iso(m[3],m[2],m[1]); rest=t.slice(1);}
      else if(t.length&&regYMD.test(t[0])){const m=t[0].match(regYMD); date=iso(m[1],m[2],m[3]); rest=t.slice(1);}
      else{rest=t.slice(0);}
      const nums=rest.map(Number).filter(n=>!Number.isNaN(n));
      if(!date){ const only=(line.match(/\d+/g)||[]).map(Number); if(only.length>=7){ const [a,b,c]=only.slice(0,3); const d=iso(c,b,a); if(d) date=d; } }
      const main=nums.filter(n=>n>=1&&n<=50).slice(0,5).sort((a,b)=>a-b);
      const euro=nums.filter(n=>n>=1&&n<=12).slice(0,2).sort((a,b)=>a-b);
      if(!date||main.length!==5||euro.length!==2) return null;
      return {date,main,euro};
    }
    draws=[]; freqMain.fill(0); freqEuro.fill(0); lastSeen.fill(null); lastSeenE.fill(null);
    cleaned.forEach(l=>{ const r=parseLine(l); if(r) draws.push(r); });
    if(!draws.length) throw new Error('Keine g√ºltigen Ziehungen erkannt.');
    draws.sort((a,b)=>a.date.localeCompare(b.date));
    draws.forEach((d,idx)=>{ d.main.forEach(n=>{freqMain[n]++; lastSeen[n]=idx;}); d.euro.forEach(n=>{freqEuro[n]++; lastSeenE[n]=idx;}); });
    localStorage.setItem(ARCH_KEY, txt);
    // Wenn Quelle "latest" ist, Referenz-Enddatum speichern
    if(source==='latest'){
      latestRefDate = draws.at(-1).date;
      localStorage.setItem(LATEST_REF_KEY, latestRefDate);
    }
    $('#statusText').textContent='Archiv geladen ‚úî';
    setKPIs(); renderCharts(); renderAnalyseKPIs();
  }catch(e){ $('#statusText').textContent='Fehler: '+e.message; }
}

/* === Buttons =============================================================== */
document.getElementById('loadLatestBtn').addEventListener('click', async ()=>{
  const url=$('#archiveUrl').value.trim();
  $('#statusText').textContent='Lade neuestes Archiv‚Ä¶';
  try{ const text=await fetchWithProxies(url); parseArchiveText(text, 'latest'); }
  catch(e){
    $('#statusText').innerHTML="Download nicht m√∂glich. <a class='underline' target='_blank' href='"+url+"'>Manuell √∂ffnen</a>.";
  }
});
document.getElementById('forceDlBtn').addEventListener('click', async ()=>{
  const url=$('#archiveUrl').value.trim();
  const trials=['https://cors.isomorphic-git.org/'+url,'https://api.allorigins.win/raw?url='+encodeURIComponent(url),'https://thingproxy.freeboard.io/fetch/'+url,'https://corsproxy.io/?'+encodeURIComponent(url),url];
  let last=null;
  for(const u of trials){
    try{
      const res=await fetch(u); if(!res.ok) throw new Error('HTTP '+res.status);
      const blob=await res.blob();
      const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='archiv_eurojackpot.zip'; a.click(); URL.revokeObjectURL(a.href);
      return;
    }catch(e){ last=e; }
  }
  alert('Direkt-Download nicht m√∂glich: '+(last?.message||'Unbekannt'));
});
(function(){ const u=$('#archiveUrl').value.trim(); $('#directDl').href=u; })();

document.getElementById('zipInput').addEventListener('change', async (e)=>{
  const file=e.target.files?.[0]; if(!file) return; $('#fileName').textContent=file.name;
  try{
    let text='';
    if(file.name.toLowerCase().endsWith('.zip')){
      if(!(await ensureJSZip())){ alert('JSZip nicht verf√ºgbar ‚Äì bitte ZIP entpacken und TXT/CSV hochladen.'); return; }
      const zip=await JSZip.loadAsync(file); const entries=Object.values(zip.files);
      let entry=entries.find(f=>/\.(txt|csv)$/i.test(f.name) && /eurojackpot/i.test(f.name)) || entries.find(f=>/\.(txt|csv)$/i.test(f.name));
      if(!entry) throw new Error('ZIP ohne TXT/CSV.');
      text=await entry.async('string');
    }else{ text=await file.text(); }
    // Manuelle Datei = Quelle "manual", keine Aktualisierung der "latestRefDate"
    parseArchiveText(text, 'manual');
  }catch(err){ $('#statusText').textContent='Fehler: '+err.message; }
});

/* Drag & Drop */
document.body.addEventListener('dragover', e=>{ e.preventDefault(); });
document.body.addEventListener('drop', async e=>{
  e.preventDefault();
  const file=e.dataTransfer?.files?.[0]; if(!file) return;
  $('#fileName').textContent = file.name;
  $('#statusText').textContent='Lade Datei‚Ä¶';
  try{
    let text='';
    if(file.name.toLowerCase().endsWith('.zip')){
      if(!(await ensureJSZip())){ alert('JSZip nicht verf√ºgbar ‚Äì bitte ZIP entpacken und TXT/CSV hochladen.'); return; }
      const zip=await JSZip.loadAsync(file); const entries=Object.values(zip.files);
      let entry=entries.find(f=>/\.(txt|csv)$/i.test(f.name) && /eurojackpot/i.test(f.name)) || entries.find(f=>/\.(txt|csv)$/i.test(f.name));
      if(!entry) throw new Error('ZIP ohne TXT/CSV.');
      text=await entry.async('string');
    }else{ text=await file.text(); }
    parseArchiveText(text, 'manual');
  }catch(e){ $('#statusText').textContent='Fehler: '+e.message; }
});

/* === Analyse (Charts + KPIs) ============================================== */
let chartMain, chartEuro;
function renderCharts(){
  if(!draws.length) return;
  if(chartMain) chartMain.destroy(); if(chartEuro) chartEuro.destroy();
  chartMain=new Chart($('#chartMain'),{type:'bar',data:{labels:[...Array(50).keys()].slice(1),datasets:[{data:[...freqMain].slice(1), borderWidth:0}]},options:{plugins:{legend:{display:false}}}});
  chartEuro=new Chart($('#chartEuro'),{type:'bar',data:{labels:[...Array(12).keys()].slice(1),datasets:[{data:[...freqEuro].slice(1), borderWidth:0}]},options:{plugins:{legend:{display:false}}}});
}
function renderAnalyseKPIs(){
  if(!draws.length) return;
  const mf = [...freqMain].map((v,i)=>[i,v]).slice(1).sort((a,b)=>b[1]-a[1]);
  const lf = [...freqMain].map((v,i)=>[i,v]).slice(1).sort((a,b)=>a[1]-b[1]);
  $('#kpiTop').textContent = mf.slice(0,5).map(x=>x[0]).join(' ');
  $('#kpiLow').textContent = lf.slice(0,5).map(x=>x[0]).join(' ');
  const recent = draws.slice(-20);
  const counts=Array(51).fill(0); recent.forEach(d=>d.main.forEach(n=>counts[n]++));
  const hot = counts.map((v,i)=>[i,v]).slice(1).sort((a,b)=>b[1]-a[1]).slice(0,5).map(x=>x[0]).join(' ');
  $('#kpiHot').textContent = hot;
  const last=draws.slice(-200);
  const map=new Map();
  function inc(k){ map.set(k,(map.get(k)||0)+1); }
  last.forEach(d=>{ const m=[...d.main].sort((a,b)=>a-b); for(let i=0;i<m.length;i++) for(let j=i+1;j<m.length;j++) inc(`${m[i]}-${m[j]}`); });
  const pairs=[...map.entries()].sort((a,b)=>b[1]-a[1]).slice(0,3).map(([k,v])=>k).join('  ');
  $('#kpiPairs').textContent = pairs;
}

/* === Gruppen & Generator =================================================== */
const GROUPS=[{label:'1‚Äì10',from:1,to:10},{label:'11‚Äì20',from:11,to:20},{label:'21‚Äì30',from:21,to:30},{label:'31‚Äì40',from:31,to:40},{label:'41‚Äì50',from:41,to:50}];
const EGROUPS=[{label:'1‚Äì6',from:1,to:6},{label:'7‚Äì12',from:7,to:12}];
function buildGroupUI(){
  const host=$('#groupControls'); host.innerHTML='';
  GROUPS.forEach((g,i)=>{
    const row=document.createElement('div'); row.className='grid grid-cols-3 gap-2 items-center';
    row.innerHTML=`<div class="font-bold">${g.label}</div><select class="bg-gray-900 p-2 rounded" data-idx="${i}">${[0,1,2,3,4,5].map(v=>`<option value="${v}">${v}</option>`).join('')}</select><div class="text-right text-sm text-gray-400">0</div>`;
    host.appendChild(row);
  });
  $$('#groupControls select').forEach(sel=> sel.addEventListener('change', updateGroupCounters));
  updateGroupCounters();
}
function buildEuroUI(){
  const host=$('#euroControls'); host.innerHTML='';
  EGROUPS.forEach((g,i)=>{
    const row=document.createElement('div'); row.className='grid grid-cols-3 gap-2 items-center';
    row.innerHTML=`<div class="font-bold">${g.label}</div><select class="bg-gray-900 p-2 rounded euro" data-idx="${i}">${[0,1,2].map(v=>`<option value="${v}">${v}</option>`).join('')}</select><div class="text-right text-sm text-gray-400">0</div>`;
    host.appendChild(row);
  });
  $$('#euroControls select').forEach(sel=> sel.addEventListener('change', updateGroupCounters));
}
function setCounter(el, val, total){
  el.textContent = `${val}/${total}`;
  el.classList.toggle('green', val===total);
  el.classList.toggle('red', val!==total);
}
function updateGroupCounters(){
  let sumG=0; $$('#groupControls select').forEach(s=>{ const v=+s.value||0; sumG+=v; s.parentElement.lastChild.textContent=v; });
  setCounter($('#mainCounter'), sumG, 5);
  let sumE=0;
  if($('#useEuro').checked){
    $$('#euroControls select').forEach(s=>{ const v=+s.value||0; sumE+=v; s.parentElement.lastChild.textContent=v; });
    $('#euroCounter').classList.remove('hidden');
    setCounter($('#euroCounter'), sumE, 2);
  }else{
    $('#euroCounter').classList.add('hidden');
  }
  const err=$('#groupError'); err.classList.add('hidden'); err.textContent='';
  if(sumG!==5){ err.classList.remove('hidden'); err.textContent='Bitte genau 5 aus den Gruppen w√§hlen.'; }
  if($('#useEuro').checked && !(sumE===0 || sumE===2)){ err.classList.remove('hidden'); err.textContent='Euro-Summe muss 0 oder 2 sein.'; }
}
$('#modus').addEventListener('change', ()=>{
  const on = $('#modus').value==='groups';
  $('#groupUI').classList.toggle('hidden', !on);
  if(on){ buildGroupUI(); }
});
$('#useEuro').addEventListener('change', e=>{
  $('#euroControls').classList.toggle('hidden', !e.target.checked);
  if(e.target.checked){ buildEuroUI(); setCounter($('#euroCounter'), 0, 2); }
  updateGroupCounters();
});

function shuffle(a){ for(let i=a.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]];} return a; }
function pickFromRange(from,to,avoid,count,weightFn){
  const bag=[]; for(let n=from;n<=to;n++){ if(!avoid.includes(n)){ const w=Math.max(1, weightFn?weightFn(n):1); for(let k=0;k<w;k++) bag.push(n);} }
  shuffle(bag);
  const res=[]; for(const v of bag){ if(!res.includes(v)){ res.push(v); if(res.length===count) break; } }
  return res;
}
function euroAuto(){
  const fe=[...freqEuro]; const maxE=Math.max(...fe.slice(1))||1;
  const lastIdx=draws.length-1;
  const w = (e)=>{
    const f = fe[e]/maxE;
    const gap = lastSeenE[e]!=null ? (lastIdx-lastSeenE[e]) : lastIdx+1;
    const gapN = Math.min(1, gap/(lastIdx+1));
    return 1 + Math.round(3*(0.55*f + 0.45*gapN));
  };
  const e = pickFromRange(1,12,[],2,w).sort((a,b)=>a-b);
  return e;
}

const normalizeVec = v => { const m=Math.max(...v); return v.map(x=> m? x/m : 0); };
function buildMatrices(){
  const C = Array.from({length:51}, ()=>Array(51).fill(0));
  const recentW = Math.min(150, draws.length);
  const recentStart = draws.length - recentW;
  const recentF = Array(51).fill(0);
  for(let i=0;i<draws.length;i++){
    const d=draws[i]; const m=d.main;
    for(let a=0;a<m.length;a++) for(let b=a+1;b<m.length;b++){ C[m[a]][m[b]]++; C[m[b]][m[a]]++; }
    if(i>=recentStart){ m.forEach(x=>recentF[x]++); }
  }
  const fNorm = normalizeVec(freqMain);
  const trendNorm = normalizeVec(recentF);
  const gaps = lastSeen.map(ix => ix==null ? draws.length : (draws.length-1-ix));
  const gapNorm = normalizeVec(gaps);
  const pairScore = (i,j)=>{
    const fij=C[i][j]; if(fij===0) return 0;
    const denom = (freqMain[i]||1)*(freqMain[j]||1);
    return fij/denom;
  };
  return {pairScore, fNorm, trendNorm, gapNorm};
}
function scoreSet(set, mats){
  const {pairScore,fNorm,trendNorm,gapNorm} = mats;
  const wF=0.32, wT=0.30, wR=0.38, wPair=0.75, wBal=0.25;
  const base = set.reduce((s,n)=> s + (wF*fNorm[n] + wT*trendNorm[n] + wR*gapNorm[n]), 0);
  let p=0; for(let i=0;i<set.length;i++) for(let j=i+1;j<set.length;j++){ p += pairScore(set[i],set[j]); }
  const target=[1,1,1,1,1]; const counts=[0,0,0,0,0];
  set.forEach(n=>{ const g = Math.floor((n-1)/10); counts[g]++; });
  const balPenalty = counts.reduce((s,c,i)=> s + Math.abs(c-target[i]), 0);
  const balScore = Math.max(0, 5 - balPenalty)/5;
  return base + wPair*p + wBal*balScore;
}
function complexSimulatedAnnealing(){
  const mats = buildMatrices();
  const w = n=> 1 + Math.round(5*(mats.trendNorm[n]*0.6 + mats.gapNorm[n]*0.4));
  let current = pickFromRange(1,50,[],5,w).sort((a,b)=>a-b);
  let best = current.slice();
  let currentScore = scoreSet(current, mats);
  let bestScore = currentScore;
  const ITER = 1600 + Math.floor(Math.random()*600);
  for(let t=0;t<ITER;t++){
    const T = 1 - t/ITER;
    const c = current.slice();
    const k = (Math.random()<T? 2:1);
    for(let i=0;i<k;i++){
      const rmIdx = Math.floor(Math.random()*c.length);
      const avoid = c.slice(); avoid.splice(rmIdx,1);
      const add = pickFromRange(1,50,avoid,1,w);
      if(add.length){ c[rmIdx]=add[0]; }
      c.sort((a,b)=>a-b);
    }
    const s = scoreSet(c, mats);
    const accept = (s>currentScore) || (Math.random()<Math.exp((s-currentScore)/(0.15+0.0001)));
    if(accept){ current=c; currentScore=s; if(s>bestScore){ best=c; bestScore=s; } }
  }
  return {main:best, euro:euroAuto()};
}
function runsBest(){
  const runMap=new Map();
  function inc(key){ runMap.set(key,(runMap.get(key)||0)+1); }
  for(const d of draws){
    const m=[...d.main].sort((a,b)=>a-b);
    let seq=[m[0]];
    for(let i=1;i<m.length;i++){
      if(m[i]===m[i-1]+1){ seq.push(m[i]); }
      else{
        if(seq.length>=2){ for(let L=2; L<=Math.min(4,seq.length); L++){ for(let s=0;s+L<=seq.length;s++){ inc(seq.slice(s,s+L).join('-')); } } }
        seq=[m[i]];
      }
    }
    if(seq.length>=2){ for(let L=2; L<=Math.min(4,seq.length); L++){ for(let s=0;s+L<=seq.length;s++){ inc(seq.slice(s,s+L).join('-')); } } }
  }
  const lastIdx = draws.length-1;
  const scoreEntries=[];
  for(const [k,v] of runMap.entries()){
    const nums=k.split('-').map(Number);
    const lastSeenMin = Math.min(...nums.map(n=> lastSeen[n]==null? -1 : lastSeen[n]));
    const gap = lastSeenMin<0? lastIdx+1 : (lastIdx-lastSeenMin);
    const fresh = 1 + gap/(lastIdx+1);
    scoreEntries.push([nums, v*fresh]);
  }
  scoreEntries.sort((a,b)=>b[1]-a[1]);
  const pick = scoreEntries.slice(0,50);
  const base = pick.length? pick[Math.floor(Math.random()*Math.min(12,pick.length))][0] : [];
  let main = Array.from(new Set(base));
  while(main.length<5){
    const add = pickFromRange(1,50,main,1, n=> (freqMain[n]? freqMain[n]:1) + (lastSeen[n]==null?3:0) );
    if(add.length) main.push(add[0]); else break;
  }
  main = Array.from(new Set(main)).sort((a,b)=>a-b).slice(0,5);
  return {main, euro:euroAuto()};
}

/* Typing Engine */
async function typeLine(el, text){ for(const ch of text){ el.append(ch); await sleep(10);} }
async function printTip(outEl, index, tip){
  await typeLine(outEl, "#"+index+": ");
  for(const n of tip.main){ await typeLine(outEl, n+" "); }
  await typeLine(outEl, "| E: ");
  for(const e of tip.euro){ await typeLine(outEl, e+" "); }
  outEl.append("\n"); outEl.scrollTop = outEl.scrollHeight;
}

/* Analyse & Karten */
function inFav(tip){ return favorites.some(f=> f.main.join('-')===tip.main.join('-') && f.euro.join('-')===tip.euro.join('-')); }
function exactOccurrences(tip){
  const idx=[]; for(let i=0;i<draws.length;i++){ const d=draws[i];
    if(tip.main.length===5 && d.main.length===5 && tip.main.every((n,j)=>n===d.main[j])) idx.push(i);
  } return idx;
}
function analyseVariant(tip){
  const idx=exactOccurrences(tip);
  const occurCount=idx.length;
  const last = occurCount? draws[idx.at(-1)].date : 'nie';
  const avgGap = occurCount? (function(){
    let gaps=[]; for(let i=1;i<idx.length;i++) gaps.push(idx[i]-idx[i-1]); const m=gaps.reduce((a,b)=>a+b,0)/(gaps.length||1); return m.toFixed(1);
  })() : '‚Äì';
  const first = occurCount? draws[idx[0]].date : '‚Äì';
  const dist = Array(8).fill(0);
  for(const d of draws){ const ov = tip.main.filter(x=>d.main.includes(x)).length + tip.euro.filter(x=>d.euro.includes(x)).length; dist[ov]++; }
  const ov3p = dist.slice(3).reduce((a,b)=>a+b,0);
  const freqSum = tip.main.reduce((s,n)=>s+freqMain[n],0);
  return {occurCount,last,first,avgGap,dist,ov3p,freqSum};
}
function tipCard(idx, tip){
  const a = analyseVariant(tip);
  const isFav = inFav(tip);
  const card=document.createElement('div'); card.className='glass mb-3'; card.dataset.key = tip.main.join('-')+'|'+tip.euro.join('-');
  card.innerHTML = `
    <div class="flex items-center justify-between">
      <div>
        ${tip.main.map(n=>`<span class="chip">${n}</span>`).join('')}
        <span class="badge">Euro</span>
        ${tip.euro.map(n=>`<span class="chip euro">${n}</span>`).join('')}
      </div>
      <span class="badge">#${idx}</span>
    </div>
    <div class="grid grid-cols-2 md:grid-cols-3 gap-2 mt-2 text-sm">
      <div class="badge">Vorkommen exakt: <b>${a.occurCount}</b></div>
      <div class="badge">Erstes: <b>${a.first}</b></div>
      <div class="badge">Letztes: <b>${a.last}</b></div>
      <div class="badge">√ò Abstand: <b>${a.avgGap}</b></div>
      <div class="badge">Overlap ‚â•3: <b>${a.ov3p}</b></div>
      <div class="badge">FreqSum: <b>${a.freqSum}</b></div>
    </div>
    <div class="mt-2 flex gap-2 flex-wrap">
      <button class="btn ${isFav?'btn--green':'btn--amber'} fav-toggle">${isFav?'‚úÖ In Favoriten':'‚≠ê Favorit'}</button>
      <button class="btn btn--gray copy-btn">üìã Kopieren</button>
      <button class="btn btn--gray del-btn">üóëÔ∏è Entfernen</button>
    </div>`;
  card.querySelector('.copy-btn').onclick = ()=> navigator.clipboard.writeText(`${tip.main.join('-')} | E:${tip.euro.join('-')}`);
  card.querySelector('.del-btn').onclick = ()=>{ card.remove(); generated = generated.filter(g=> g!==tip); };
  card.querySelector('.fav-toggle').onclick = (ev)=>{
    if(inFav(tip)){
      favorites = favorites.filter(f=> !(f.main.join('-')===tip.main.join('-') && f.euro.join('-')===tip.euro.join('-')));
    }else{
      favorites.push(tip);
    }
    localStorage.setItem('ej_favs_v1', JSON.stringify(favorites));
    ev.target.textContent = inFav(tip) ? '‚úÖ In Favoriten' : '‚≠ê Favorit';
    ev.target.classList.toggle('btn--green', inFav(tip));
    ev.target.classList.toggle('btn--amber', !inFav(tip));
  };
  return card;
}

function generateOne(){
  const mode = $('#modus').value;
  let main=[];
  if(!draws.length){
    main = pickFromRange(1,50,[],5); return {main:main.sort((a,b)=>a-b), euro: pickFromRange(1,12,[],2).sort((a,b)=>a-b)};
  }
  if(mode==='groups'){
    const want = $$('#groupControls select').map(s=>+s.value||0);
    const sumWant = sum(want);
    const err=$('#groupError'); err.classList.add('hidden'); err.textContent='';
    if(sumWant!==5){ err.classList.remove('hidden'); err.textContent='Bitte genau 5 aus den Gruppen w√§hlen.'; throw new Error('Gruppen nicht vollst√§ndig.'); }
    let weightMain=null;
    const r=draws.slice(-100); const fm=Array(51).fill(1); r.forEach(d=>d.main.forEach(n=>fm[n]++));
    const maxM=Math.max(...fm.slice(1)); weightMain=n=>Math.ceil(3*fm[n]/maxM);
    GROUPS.forEach((g,i)=>{ const need=want[i]; if(need>0){ main.push(...pickFromRange(g.from,g.to,main,need,weightMain)); } });
    main = Array.from(new Set(main)).sort((a,b)=>a-b).slice(0,5);
    let euro=[];
    if($('#useEuro').checked){
      const eWant = $$('#euroControls select').map(s=>+s.value||0);
      const eSum = sum(eWant);
      if(!(eSum===0 || eSum===2)){ throw new Error('Euro-Summe muss 0 oder 2 sein.'); }
      if(eSum===2){ EGROUPS.forEach((g,i)=>{ const need=eWant[i]; if(need>0){ euro.push(...pickFromRange(g.from,g.to,euro,need)); } }); euro.sort((a,b)=>a-b); }
      if(eSum===0){ euro=euroAuto(); }
    }else{ euro=euroAuto(); }
    return {main, euro};
  }
  if(mode==='last100'){
    const r=draws.slice(-100); const fm=Array(51).fill(1); r.forEach(d=>d.main.forEach(n=>fm[n]++));
    const maxM=Math.max(...fm.slice(1)); const w=n=>Math.ceil(3*fm[n]/maxM);
    main = pickFromRange(1,50,[],5,w).sort((a,b)=>a-b);
    return {main, euro:euroAuto()};
  }
  if(mode==='never'){
    const fm=freqMain.slice(); const w=n=> fm[n]===0?5:(fm[n]<=5?3:1);
    main = pickFromRange(1,50,[],5,w).sort((a,b)=>a-b);
    return {main, euro:euroAuto()};
  }
  if(mode==='hot'){
    const recent = draws.slice(-200);
    const pairMap=new Map(); const tripleMap=new Map();
    function inc(map,key){ map.set(key,(map.get(key)||0)+1); }
    for(const d of recent){
      const m=[...d.main].sort((a,b)=>a-b);
      for(let i=0;i<m.length;i++) for(let j=i+1;j<m.length;j++){ inc(pairMap, `${m[i]}-${m[j]}`); }
      for(let i=0;i<m.length;i++) for(let j=i+1;j<m.length;j++) for(let k=j+1;k<m.length;k++){ inc(tripleMap, `${m[i]}-${m[j]}-${m[k]}`); }
    }
    const topPairs=[...pairMap.entries()].sort((a,b)=>b[1]-a[1]).slice(0,30).map(e=>e[0].split('-').map(Number));
    const topTrip=[...tripleMap.entries()].sort((a,b)=>b[1]-a[1]).slice(0,20).map(e=>e[0].split('-').map(Number));
    if(Math.random()<0.5 && topTrip.length){ main = [...topTrip[Math.floor(Math.random()*topTrip.length)]]; }
    else if(topPairs.length){ main = [...topPairs[Math.floor(Math.random()*topPairs.length)]]; }
    const r2=draws.slice(-100); const fm=Array(51).fill(1); r2.forEach(d=>d.main.forEach(n=>fm[n]++));
    const maxM=Math.max(...fm.slice(1)); const w=n=>Math.ceil(2*fm[n]/maxM);
    while(main.length<5){ const add = pickFromRange(1,50,main,1,w); if(add.length) main.push(add[0]); else break; }
    main.sort((a,b)=>a-b);
    return {main, euro:euroAuto()};
  }
  if(mode==='complex'){ return complexSimulatedAnnealing(); }
  if(mode==='runs'){ return runsBest(); }
  main = pickFromRange(1,50,[],5).sort((a,b)=>a-b); return {main, euro:euroAuto()};
}

async function printTipAndCard(outEl, index, tip){
  await printTip(outEl, index, tip);
  $('#cards').appendChild(tipCard(index, tip));
}

/* Buttons Generator/Analyse */
$('#generateBtn').addEventListener('click', async ()=>{
  if(!draws.length){ alert('Bitte zuerst ein Archiv laden.'); return; }
  if($('#modus').value==='groups' && $('#groupControls').children.length===0){ buildGroupUI(); }
  const total = +$('#kombis').value || 1;
  const out = $('#liveOutput'); out.textContent='';
  $('#cards').innerHTML='';
  generated=[];
  const seen=new Set();
  for(let i=1;i<=total;i++){
    try{
      let tip = generateOne();
      let key = tip.main.join('-')+'|'+tip.euro.join('-');
      let guard=0; while(seen.has(key) && guard<10){ tip = generateOne(); key=tip.main.join('-')+'|'+tip.euro.join('-'); guard++; }
      seen.add(key); generated.push(tip);
      await animateSelection(tip.main, tip.euro);
      await printTipAndCard(out, i, tip);
    }catch(e){
      const err=$('#groupError'); err.classList.remove('hidden'); err.textContent=e.message; break;
    }
  }
});
$('#clearGeneratedBtn').addEventListener('click', ()=>{ generated=[]; $('#cards').innerHTML=''; $('#liveOutput').textContent=''; });
$('#analyseAllBtn').addEventListener('click', ()=>{
  if(!generated.length){ alert('Bitte zuerst Varianten generieren.'); return; }
  const dist=Array(8).fill(0);
  generated.forEach(t=>{ for(const d of draws){ const ov = t.main.filter(x=>d.main.includes(x)).length + t.euro.filter(x=>d.euro.includes(x)).length; dist[ov]++; } });
  const table = dist.map((v,i)=>`<tr><td class="px-2 py-1">${i}</td><td class="px-2 py-1">${v}</td></tr>`).join('');
  $('#analysisBox').innerHTML = `<div class="glass mt-2"><div class="font-bold mb-2">Overlap‚ÄëVerteilung (alle Varianten √ó Archiv)</div><table class="text-sm"><thead><tr><th class="px-2 py-1">Treffer</th><th class="px-2 py-1">Anzahl</th></tr></thead><tbody>${table}</tbody></table></div>`;
  $('#v-ana').scrollIntoView({behavior:'smooth'});
});

/* Favoriten */
function saveFavs(){ localStorage.setItem('ej_favs_v1', JSON.stringify(favorites)); renderFavs(); }
function renderFavs(){
  const q=($('#favSearch')?.value||'').toLowerCase();
  const box=$('#favoritesBox'); if(!box) return; box.innerHTML='';
  favorites.filter(f=> (f.main.join(' ')+' '+f.euro.join(' ')).toLowerCase().includes(q)).forEach((f,i)=>{
    const div=document.createElement('div'); div.className='glass p-3';
    const grid=document.createElement('div'); grid.className='flex flex-wrap items-center gap-1';
    f.main.forEach(n=>{ const s=document.createElement('span'); s.className='chip'; s.textContent=n; grid.appendChild(s); });
    const label=document.createElement('span'); label.className='badge ml-2'; label.textContent='Euro'; grid.appendChild(label);
    f.euro.forEach(n=>{ const s=document.createElement('span'); s.className='chip euro'; s.textContent=n; grid.appendChild(s); });
    const actions=document.createElement('div'); actions.className='mt-2 flex gap-2 flex-wrap';
    actions.innerHTML=`
      <button class="btn btn--gray" onclick='navigator.clipboard.writeText("${f.main.join('-')} | E:${f.euro.join('-')}")'>Copy</button>
      <button class="btn btn--gray" onclick='animateSelection(${JSON.stringify(f.main)}, ${JSON.stringify(f.euro)})'>Show</button>
      <button class="btn btn--gray" onclick="favorites.splice(${i},1); saveFavs();" style="border-color: rgba(255,0,0,.25)">Entfernen</button>`;
    div.appendChild(grid); div.appendChild(actions); box.appendChild(div);
  });
}
$('#favSearch')?.addEventListener('input', renderFavs);
$('#favExport')?.addEventListener('click', ()=>{
  const blob=new Blob([JSON.stringify(favorites,null,2)],{type:'application/json'});
  const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download='favoriten.json'; a.click(); URL.revokeObjectURL(url);
});
$('#favCSV')?.addEventListener('click', ()=>{
  const rows = [["n1","n2","n3","n4","n5","e1","e2"], ...favorites.map(f=>[...f.main, ...f.euro])];
  const csv = rows.map(r=>r.join(",")).join("\n");
  const blob=new Blob([csv],{type:'text/csv'});
  const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download='favoriten.csv'; a.click(); URL.revokeObjectURL(url);
});
$('#favImport')?.addEventListener('click', ()=>{
  const inp=document.createElement('input'); inp.type='file'; inp.accept='.json';
  inp.onchange=async e=>{ const file=e.target.files?.[0]; if(!file) return; const txt=await file.text(); favorites=JSON.parse(txt||'[]'); saveFavs(); };
  inp.click();
});
$('#favClear')?.addEventListener('click', ()=>{ if(confirm('Alle Favoriten l√∂schen?')){ favorites=[]; saveFavs(); } });
renderFavs();

/* Restore */
(()=>{
  const saved=localStorage.getItem(ARCH_KEY);
  if(saved){ try{ parseArchiveText(saved, 'manual'); $('#statusText').textContent='Archiv aus Speicher geladen ‚úî'; }catch{} }
  latestRefDate = localStorage.getItem(LATEST_REF_KEY) || latestRefDate;
  setKPIs();
})();

/* === Trommel-Physik ======================================================== */
(function(){
  // Canvas setup
  const canvas = document.getElementById('drumCanvas');
  if(!canvas) return;
  const ctx = canvas.getContext('2d');

  // Scale: 1 "Ball" = 45 mm -> map to 20 px diameter for good visuals
  const BALL_DIAM_PX = 20;
  const RADIUS = BALL_DIAM_PX/2;
  const MASS = 4; // g (used relatively, all equal mass)
  const W = canvas.width, H = canvas.height;
  const CX = W*0.5, CY = H*0.52;
  const DRUM_R = Math.min(W,H)*0.42;

  // Gate (Fangstutzen) at top-right
  const GATE_POS = {x: CX + DRUM_R*0.55, y: CY - DRUM_R*0.20};
  const GATE_R = 18;

  // Controls
  const rpmEl = document.getElementById('rpm');
  const rpmVal = document.getElementById('rpmVal');
  const dragEl = document.getElementById('drag');
  const dragVal = document.getElementById('dragVal');
  const startBtn = document.getElementById('drumStart');
  const pauseBtn = document.getElementById('drumPause');
  const resetBtn = document.getElementById('drumReset');
  const autoBtn = document.getElementById('autoDraw');
  const pickBtn = document.getElementById('pickOne');
  const outMain = document.getElementById('drumOutMain');
  const outEuro = document.getElementById('drumOutEuro');

  let running=false, rafId=null, mode='main';
  let balls=[], drawnMain=[], drawnEuro=[];
  let lastTime=0;

  function setMode(m){
    mode=m;
    document.querySelectorAll('input[name=drummode]').forEach(r=>{
      if(r.value===m) r.checked=true;
    });
    initBalls();
    renderOutputs();
  }
  document.querySelectorAll('input[name=drummode]').forEach(r=>{
    r.addEventListener('change',e=> setMode(e.target.value));
  });

  function renderOutputs(){
    function pill(n, euro=false){
      const span=document.createElement('span');
      span.className='chip'+(euro?' euro':'');
      span.textContent=n;
      return span;
    }
    outMain.innerHTML=''; drawnMain.forEach(n=> outMain.appendChild(pill(n,false)));
    outEuro.innerHTML=''; drawnEuro.forEach(n=> outEuro.appendChild(pill(n,true)));
  }

  function rng(a,b){ return a + Math.random()*(b-a); }

  function initBalls(){
    balls.length=0;
    const count = (mode==='main')? 50 : 12;
    const labels = Array.from({length:count},(_,i)=> i+1);
    // Fill with jittered circle placement
    for(let i=0;i<count;i++){
      const angle = Math.random()*Math.PI*2;
      const r = DRUM_R*0.5*rng(0.6,0.98);
      const x = CX + r*Math.cos(angle);
      const y = CY + r*Math.sin(angle);
      const speed = rng(40, 80); // px/s initial
      const dir = angle + Math.PI/2;
      balls.push({
        id: labels[i],
        x, y,
        vx: speed*Math.cos(dir),
        vy: speed*Math.sin(dir),
        r: RADIUS,
        m: MASS,
      });
    }
  }
  initBalls();

  function drawDrum(){
    // background
    ctx.clearRect(0,0,W,H);
    // drum glass
    ctx.save();
    ctx.beginPath();
    ctx.arc(CX, CY, DRUM_R, 0, Math.PI*2);
    ctx.strokeStyle='rgba(180,220,255,0.35)';
    ctx.lineWidth=8;
    ctx.stroke();
    ctx.restore();

    // gate
    ctx.beginPath();
    ctx.arc(GATE_POS.x, GATE_POS.y, GATE_R, 0, Math.PI*2);
    ctx.strokeStyle='rgba(255, 255, 255, 0.25)';
    ctx.lineWidth=2;
    ctx.stroke();
    ctx.font='12px Inter, sans-serif';
    ctx.fillStyle='rgba(255,255,255,.5)';
    ctx.fillText('Fang', GATE_POS.x-12, GATE_POS.y-18);
  }

  function drawBall(b){
    ctx.save();
    ctx.beginPath();
    ctx.arc(b.x,b.y,b.r,0,Math.PI*2);
    ctx.fillStyle = (mode==='euro') ? 'rgba(255,230,255,0.95)' : 'rgba(189,252,255,0.95)';
    ctx.fill();
    ctx.lineWidth=1.5;
    ctx.strokeStyle=(mode==='euro') ? 'rgba(255,0,234,0.5)':'rgba(0,255,255,0.45)';
    ctx.stroke();
    ctx.fillStyle='#111';
    ctx.font='bold 12px Inter, system-ui';
    const txt = String(b.id);
    const w = ctx.measureText(txt).width;
    ctx.fillText(txt, b.x - w/2, b.y + 4);
    ctx.restore();
  }

  function step(dt){
    const rpm = Number(rpmEl.value);
    rpmVal.textContent = `${rpm} U/min`;
    const drag = Number(dragEl.value);
    dragVal.textContent = drag.toFixed(3);

    // Convert rpm to angular speed (rad/s)
    const omega = rpm * 2*Math.PI / 60;

    // Swirl field to mimic "Waschmaschine"
    for(const b of balls){
      // vector from center
      const dx=b.x-CX, dy=b.y-CY;
      const dist=Math.hypot(dx,dy) || 0.0001;
      // tangential acceleration
      const tx = -dy/dist, ty = dx/dist;
      const swirl = omega*120; // tune factor to feel lively
      b.vx += tx*swirl*dt;
      b.vy += ty*swirl*dt;

      // slight radial push outward (centrifugal effect)
      const radial = omega*30;
      b.vx += (dx/dist)*radial*dt;
      b.vy += (dy/dist)*radial*dt;

      // air drag (depends on "Styropor" ‚Äì light, so noticeable)
      b.vx *= (1 - drag);
      b.vy *= (1 - drag);

      // integrate
      b.x += b.vx*dt;
      b.y += b.vy*dt;

      // wall collision (circle)
      const vx=b.vx, vy=b.vy;
      const fromC = Math.hypot(b.x-CX,b.y-CY);
      const maxR = DRUM_R - b.r - 4;
      if(fromC>maxR){
        // project back on boundary
        const nx = (b.x-CX)/fromC, ny=(b.y-CY)/fromC;
        b.x = CX + nx*maxR;
        b.y = CY + ny*maxR;
        // reflect velocity on normal with little energy loss (Styropor is bouncy but light)
        const vn = vx*nx + vy*ny;
        const vt_x = vx - vn*nx, vt_y = vy - vn*ny;
        const restitution = 0.85;
        b.vx = vt_x - restitution*vn*nx;
        b.vy = vt_y - restitution*vn*ny;
      }
    }

    // ball-ball collisions (elastic, equal mass)
    for(let i=0;i<balls.length;i++){
      for(let j=i+1;j<balls.length;j++){
        const a=balls[i], b=balls[j];
        const dx=b.x-a.x, dy=b.y-a.y;
        const dist2 = dx*dx+dy*dy;
        const rsum=a.r+b.r;
        if(dist2 < rsum*rsum){
          const dist = Math.sqrt(dist2)||0.0001;
          const nx=dx/dist, ny=dy/dist;
          const p = (a.vx - b.vx)*nx + (a.vy - b.vy)*ny;
          if(p>0) continue;
          const imp = (-2*p)/(1+1); // equal mass
          a.vx += imp*nx;
          a.vy += imp*ny;
          b.vx -= imp*nx;
          b.vy -= imp*ny;
          // separate
          const overlap = (rsum - dist)/2;
          a.x -= nx*overlap; a.y -= ny*overlap;
          b.x += nx*overlap; b.y += ny*overlap;
        }
      }
    }
  }

  function draw(){
    drawDrum();
    for(const b of balls) drawBall(b);
  }

  function loop(ts){
    if(!running){ return; }
    const t = ts*0.001;
    const dt = Math.min(0.033, lastTime? (t-lastTime): 0.016);
    lastTime = t;
    step(dt);
    draw();
    rafId = requestAnimationFrame(loop);
  }

  function start(){ if(!running){ running=true; lastTime=0; rafId=requestAnimationFrame(loop); } }
  function pause(){ running=false; if(rafId) cancelAnimationFrame(rafId); rafId=null; }
  function reset(){
    pause();
    drawnMain.length=0; drawnEuro.length=0;
    renderOutputs();
    initBalls();
    draw();
  }

  startBtn.addEventListener('click', start);
  pauseBtn.addEventListener('click', pause);
  resetBtn.addEventListener('click', reset);

  function removeBallToOutput(ball){
    // remove from balls
    balls = balls.filter(b=> b!==ball);
    // append to output
    if(mode==='main'){
      drawnMain.push(ball.id);
      drawnMain.sort((a,b)=>a-b);
    }else{
      drawnEuro.push(ball.id);
      drawnEuro.sort((a,b)=>a-b);
    }
    renderOutputs();
  }

  function tryCatchOne(){
    // If a ball is inside the gate circle and slow enough, catch it
    let candidate=null, best=1e9;
    for(const b of balls){
      const d = Math.hypot(b.x-GATE_POS.x, b.y-GATE_POS.y);
      if(d < GATE_R - 2){
        const sp = Math.hypot(b.vx,b.vy);
        if(sp < best){ best = sp; candidate=b; }
      }
    }
    if(candidate){
      removeBallToOutput(candidate);
      return true;
    }
    return false;
  }

  pickBtn.addEventListener('click', ()=>{
    // Try immediate catch; fallback: pick random near top
    if(tryCatchOne()) return;
    const nearTop = balls.filter(b=> b.y < CY - DRUM_R*0.2);
    const pick = (nearTop.length? nearTop : balls);
    if(pick.length){
      const b = pick[Math.floor(Math.random()*pick.length)];
      removeBallToOutput(b);
    }
  });

  async function autoDrawSequence(){
    // Main numbers (5), then switch mode and draw 2 Euros
    setMode('main');
    start();
    await sleep(1200);
    while(drawnMain.length<5){
      // let them tumble a bit
      await sleep(1200);
      // try to catch one, retry if needed
      let ok=false, tries=0;
      while(!ok && tries<6){
        ok = tryCatchOne();
        if(!ok){ await sleep(600); tries++; }
      }
      if(!ok && balls.length){ // hard fallback
        removeBallToOutput(balls[Math.floor(Math.random()*balls.length)]);
      }
    }
    // switch to Euro
    setMode('euro');
    start();
    await sleep(1000);
    while(drawnEuro.length<2){
      await sleep(1200);
      let ok=false, tries=0;
      while(!ok && tries<6){
        ok = tryCatchOne();
        if(!ok){ await sleep(600); tries++; }
      }
      if(!ok && balls.length){
        removeBallToOutput(balls[Math.floor(Math.random()*balls.length)]);
      }
    }
    // done
    pause();
  }
  autoBtn.addEventListener('click', autoDrawSequence);

  // initial static draw
  draw();

  // integrate with existing animateSelection to visualize picks on Map, if present
  window.__drum_get_result = function(){
    return { main: drawnMain.slice(0,5).sort((a,b)=>a-b), euro: drawnEuro.slice(0,2).sort((a,b)=>a-b) };
  };
})();

</script>
</body>
</html>
